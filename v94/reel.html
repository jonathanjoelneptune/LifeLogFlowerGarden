<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --radius: 14px;
      --bg: rgba(0,0,0,0.10);
      --fgText: rgba(255,255,255,0.92);
      --fgTextDim: rgba(255,255,255,0.72);
      --panel: rgba(0,0,0,0.42);
      --panelSoft: rgba(0,0,0,0.28);
      --stroke: rgba(255,255,255,0.12);
      --easeXfade: cubic-bezier(0.22, 0.80, 0.20, 1.00);
      --blurPx: 22px;
      --bgScale: 1.18;
      --shadow: 0 10px 30px rgba(0,0,0,0.22);
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
    }

    /* Full-bleed. No internal padding. */
    #app {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: var(--radius);
      overflow: hidden;
      background: var(--bg);
    }

    /* Background blur layer */
    .bg {
      position: absolute;
      inset: 0;
      overflow: hidden;
      background: rgba(0,0,0,0.10);
    }
    .bg img {
      position: absolute;
      inset: -8%;
      width: 116%;
      height: 116%;
      object-fit: cover;
      filter: blur(var(--blurPx)) saturate(1.05);
      transform: scale(var(--bgScale));
      opacity: 0;
      transition: opacity 520ms var(--easeXfade);
      will-change: opacity, transform, filter;
    }
    .bg img.show { opacity: 1; }

    /* Foreground image layer */
    .fg {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .fg img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: var(--fitMode, contain);
      opacity: 0;
      transition: opacity 520ms var(--easeXfade);
      will-change: opacity;
      transform: translateZ(0);
    }
    .fg img.show { opacity: 1; }

    /* Subtle vignette to help with contrast */
    .vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(ellipse at center, rgba(0,0,0,0.00) 45%, rgba(0,0,0,0.22) 100%);
      opacity: 0.65;
      transition: opacity 240ms ease;
    }

    /* Tiny classy preload bar */
    .preloadWrap {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 10px;
      height: 8px;
      display: none;
      pointer-events: none;
      z-index: 5;
    }
    .preloadWrap.on { display: block; }
    .preloadBar {
      height: 100%;
      border-radius: 999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.10);
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
    }
    .preloadFill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: rgba(255,255,255,0.70);
      transition: width 180ms ease;
    }

    /* Minimal HUD: small, transparent, auto-fades */
    .hud {
      position: absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.34);
      color: var(--fgText);
      font: 600 11px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.2px;
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events: none;
      z-index: 6;
      max-width: calc(100% - 20px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .hud.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* Controls: only on hover, small, responsive */
    .controls {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%) translateY(8px);
      display: flex;
      align-items: center;
      gap: clamp(8px, 1.2vw, 14px);
      padding: clamp(6px, 1.0vw, 10px) clamp(8px, 1.5vw, 14px);
      border-radius: 999px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      opacity: 0;
      transition: opacity 220ms ease, transform 220ms ease;
      z-index: 7;
    }
    #app:hover .controls,
    .controls.forceShow {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .btn {
      width: clamp(26px, 2.6vw, 34px);
      height: clamp(26px, 2.6vw, 34px);
      display: grid;
      place-items: center;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 120ms ease, background 120ms ease, opacity 160ms ease, border-color 160ms ease;
    }
    .btn:hover { transform: scale(1.05); background: rgba(255,255,255,0.14); }
    .btn:active { transform: scale(0.98); }

    .btn[aria-disabled="true"]{
      opacity: 0.38;
      cursor: default;
      transform: none;
    }
    .btn svg{
      width: clamp(14px, 1.35vw, 18px);
      height: clamp(14px, 1.35vw, 18px);
      fill: rgba(255,255,255,0.90);
    }

    /* Empty / error state */
    .empty {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.18);
      color: rgba(255,255,255,0.92);
      text-align: center;
      padding: 16px;
      box-sizing: border-box;
      z-index: 10;
    }
    .emptyCard {
      max-width: min(520px, 92vw);
      padding: 14px 16px;
      border-radius: 16px;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
    }
    .emptyTitle {
      font: 800 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.2px;
    }
    .emptySub {
      margin-top: 6px;
      font: 600 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      opacity: 0.86;
    }
    .emptyErr {
      margin-top: 10px;
      font: 500 11px/1.35 ui-monospace, Menlo, Consolas, monospace;
      opacity: 0.78;
      white-space: pre-wrap;
      word-break: break-word;
      text-align: left;
      background: rgba(0,0,0,0.18);
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }
  </style>
</head>

<body>
  <div id="app" aria-label="Photo reel">
    <div class="bg" id="bg"></div>
    <div class="fg" id="fg"></div>
    <div class="vignette"></div>

    <div class="preloadWrap" id="preloadWrap">
      <div class="preloadBar"><div class="preloadFill" id="preloadFill"></div></div>
    </div>

    <div class="hud" id="hud"></div>

    <div class="controls" id="controls" aria-label="Controls">
      <div class="btn" id="btnPrev" title="Previous" aria-disabled="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M15.6 18.2 9.4 12l6.2-6.2L14.2 4.4 6.6 12l7.6 7.6z"/></svg>
      </div>
      <div class="btn" id="btnPlay" title="Pause" aria-disabled="false">
        <svg id="iconPlay" viewBox="0 0 24 24" aria-hidden="true" style="display:none"><path d="M8 5v14l11-7z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 5h5v14H6zm7 0h5v14h-5z"/></svg>
      </div>
      <div class="btn" id="btnNext" title="Next" aria-disabled="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8.4 5.8 14.6 12l-6.2 6.2L9.8 19.6 17.4 12 9.8 4.4z"/></svg>
      </div>
    </div>

    <div class="empty" id="empty" style="display:none;">
      <div class="emptyCard">
        <div class="emptyTitle" id="emptyTitle">No photos</div>
        <div class="emptySub" id="emptySub"></div>
        <div class="emptyErr" id="emptyErr" style="display:none;"></div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      "use strict";

      // -----------------------------
      // Query params
      // -----------------------------
      const qs = new URLSearchParams(location.search);

      const api = (qs.get("api") || "").trim();
      const bot = (qs.get("bot") || "").trim();
      const dateKey = (qs.get("date") || "").trim();

      const fit = (qs.get("fit") || "contain").toLowerCase().trim(); // contain | cover
      const fitMode = (fit === "cover") ? "cover" : "contain";
      document.documentElement.style.setProperty("--fitMode", fitMode);

      const w = toInt(qs.get("w"), 1200, 200, 4096);
      const cache_s = toInt(qs.get("cache_s"), 600, 0, 86400);
      const preloadN = toInt(qs.get("preload"), 2, 0, 12);

      const interval_ms = toInt(qs.get("interval_ms"), 2600, 500, 30000);
      const fade_ms = toInt(qs.get("fade_ms"), 700, 150, 6000);

      const shuffle = (qs.get("shuffle") || "0").trim() === "1";

      // "Fade controls sooner while playing, longer when paused"
      const controlsHidePlayingMs = 1400;
      const controlsHidePausedMs  = 4200;

      // Apply fade duration
      const fg = document.getElementById("fg");
      const bg = document.getElementById("bg");
      const hud = document.getElementById("hud");
      const controls = document.getElementById("controls");

      // update CSS transition durations dynamically
      const fadeDur = Math.max(0, fade_ms|0);
      injectFadeDurations(fadeDur);

      // Preload UI
      const preloadWrap = document.getElementById("preloadWrap");
      const preloadFill = document.getElementById("preloadFill");

      // Empty state
      const empty = document.getElementById("empty");
      const emptyTitle = document.getElementById("emptyTitle");
      const emptySub = document.getElementById("emptySub");
      const emptyErr = document.getElementById("emptyErr");

      // Controls
      const btnPrev = document.getElementById("btnPrev");
      const btnNext = document.getElementById("btnNext");
      const btnPlay = document.getElementById("btnPlay");
      const iconPlay = document.getElementById("iconPlay");
      const iconPause = document.getElementById("iconPause");

      let photos = [];
      let order = [];            // indices in display order
      let orderPos = 0;
      let isPaused = false;
      let timer = null;

      // Two-layer crossfade (bg+fg)
      const fgImgs = [mkImg(), mkImg()];
      const bgImgs = [mkBgImg(), mkBgImg()];
      let slot = 0; // 0 or 1, which slot is currently "next"

      fg.appendChild(fgImgs[0]);
      fg.appendChild(fgImgs[1]);
      bg.appendChild(bgImgs[0]);
      bg.appendChild(bgImgs[1]);

      // Minimal HUD text that fades away
      function showHud(text, ms=2200){
        if (!text) return;
        hud.textContent = text;
        hud.classList.add("show");
        window.clearTimeout(showHud._t);
        showHud._t = window.setTimeout(() => hud.classList.remove("show"), ms);
      }

      // Controls show/hide helper
      function showControls(forceMs){
        controls.classList.add("forceShow");
        window.clearTimeout(showControls._t);
        const hideAfter = isPaused ? controlsHidePausedMs : controlsHidePlayingMs;
        const ms = (typeof forceMs === "number") ? forceMs : hideAfter;
        showControls._t = window.setTimeout(() => controls.classList.remove("forceShow"), ms);
      }

      // Hover already shows, but we also show briefly on interaction
      ["mousemove","touchstart","pointerdown"].forEach(evt=>{
        document.getElementById("app").addEventListener(evt, ()=>{
          showControls();
        }, {passive:true});
      });

      btnPrev.addEventListener("click", () => {
        if (btnPrev.getAttribute("aria-disabled") === "true") return;
        prev();
        showControls();
      });

      btnNext.addEventListener("click", () => {
        if (btnNext.getAttribute("aria-disabled") === "true") return;
        next(true);
        showControls();
      });

      btnPlay.addEventListener("click", () => {
        if (photos.length <= 1) return;
        togglePause();
        showControls(isPaused ? controlsHidePausedMs : controlsHidePlayingMs);
      });

      function setBtnDisabled(btn, disabled){
        btn.setAttribute("aria-disabled", disabled ? "true" : "false");
      }

      function setPlayIcon(paused){
        if (paused){
          iconPlay.style.display = "";
          iconPause.style.display = "none";
          btnPlay.title = "Play";
        } else {
          iconPlay.style.display = "none";
          iconPause.style.display = "";
          btnPlay.title = "Pause";
        }
      }

      function togglePause(){
        isPaused = !isPaused;
        setPlayIcon(isPaused);
        if (isPaused){
          stopTimer();
        } else {
          startTimer();
        }
      }

      function startTimer(){
        stopTimer();
        if (photos.length <= 1) return;
        timer = window.setInterval(() => {
          if (!isPaused) next(false);
        }, interval_ms);
      }

      function stopTimer(){
        if (timer){
          window.clearInterval(timer);
          timer = null;
        }
      }

      // Non-repeating shuffle: show all once before any repeat
      function buildOrder(){
        const n = photos.length;
        const base = Array.from({length:n}, (_,i)=>i);
        if (!shuffle) return base;

        // Fisher-Yates
        for (let i = base.length - 1; i > 0; i--){
          const j = (Math.random() * (i + 1)) | 0;
          const t = base[i]; base[i] = base[j]; base[j] = t;
        }
        return base;
      }

      function advanceOrder(dir){
        const n = order.length;
        if (n === 0) return;

        // If shuffle: cycle through order and reshuffle only after completing a full cycle.
        if (shuffle){
          orderPos += dir;
          if (orderPos < 0){
            // Going backwards: wrap within current order
            orderPos = n - 1;
          } else if (orderPos >= n){
            // Completed a full pass, reshuffle and continue from start
            order = buildOrder();
            orderPos = 0;
          }
        } else {
          orderPos = (orderPos + dir + n) % n;
        }
      }

      function currentIndex(){
        if (!order.length) return 0;
        return order[orderPos] || 0;
      }

      function next(userInitiated){
        if (photos.length <= 1) return;
        advanceOrder(+1);
        renderToCurrent();
        if (userInitiated && !isPaused){
          // small UX: reset timer so it doesn't immediately auto-advance after a click
          startTimer();
        }
      }

      function prev(){
        if (photos.length <= 1) return;
        advanceOrder(-1);
        renderToCurrent();
        if (!isPaused) startTimer();
      }

      function renderToCurrent(){
        const idx = currentIndex();
        const src = photos[idx];

        // Swap slot and crossfade
        const nextSlot = slot ^ 1;

        // bg uses same image, always cover, blurred
        bgImgs[nextSlot].src = src;
        fgImgs[nextSlot].src = src;

        // force reflow so transition is consistent
        void bgImgs[nextSlot].offsetWidth;
        void fgImgs[nextSlot].offsetWidth;

        bgImgs[slot].classList.remove("show");
        fgImgs[slot].classList.remove("show");
        bgImgs[nextSlot].classList.add("show");
        fgImgs[nextSlot].classList.add("show");

        slot = nextSlot;

        // Tiny HUD: date + bot only, no photo count
        showHud(`${dateKey} • ${bot}`, 1800);

        updateDisabledButtons();
      }

      function updateDisabledButtons(){
        const one = photos.length <= 1;
        setBtnDisabled(btnPrev, one);
        setBtnDisabled(btnNext, one);
        setBtnDisabled(btnPlay, one);
      }

      function mkImg(){
        const im = document.createElement("img");
        im.alt = "photo";
        im.decoding = "async";
        im.loading = "eager";
        return im;
      }
      function mkBgImg(){
        const im = document.createElement("img");
        im.alt = "";
        im.decoding = "async";
        im.loading = "eager";
        return im;
      }

      function injectFadeDurations(ms){
        // Set transitions by updating a stylesheet rule to keep things simple.
        const css = document.createElement("style");
        css.textContent = `
          .fg img { transition-duration: ${ms}ms; }
          .bg img { transition-duration: ${Math.max(260, Math.round(ms*0.85))}ms; }
        `;
        document.head.appendChild(css);
      }

      function toInt(v, def, min, max){
        const n = Number(v);
        if (!isFinite(n)) return def;
        const r = Math.round(n);
        return Math.max(min, Math.min(max, r));
      }

      // -----------------------------
      // Loading: JSONP (CORS-safe)
      // -----------------------------
      function showEmpty(title, sub, errText){
        emptyTitle.textContent = title || "No photos";
        emptySub.textContent = sub || "";
        if (errText){
          emptyErr.style.display = "";
          emptyErr.textContent = String(errText);
        } else {
          emptyErr.style.display = "none";
          emptyErr.textContent = "";
        }
        empty.style.display = "";
      }

      function hideEmpty(){
        empty.style.display = "none";
      }

      function setPreloadProgress(pct){
        const p = Math.max(0, Math.min(100, pct));
        preloadFill.style.width = p.toFixed(0) + "%";
      }

      function withCacheBuster(url){
        // cache_s is for API-side caching, not for image URLs.
        // Still, some images can be aggressively cached; we avoid adding busters to not break caching.
        return url;
      }

      function preloadSome(urls, count){
        return new Promise((resolve) => {
          if (!count || count <= 0){
            preloadWrap.classList.remove("on");
            resolve();
            return;
          }
          const n = Math.min(count, urls.length);
          if (n <= 0){
            preloadWrap.classList.remove("on");
            resolve();
            return;
          }

          preloadWrap.classList.add("on");
          setPreloadProgress(0);

          let done = 0;
          function tick(){
            done++;
            setPreloadProgress((done / n) * 100);
            if (done >= n){
              // Let bar linger briefly
              window.setTimeout(() => {
                preloadWrap.classList.remove("on");
                resolve();
              }, 220);
            }
          }

          for (let i = 0; i < n; i++){
            const img = new Image();
            img.onload = tick;
            img.onerror = tick;
            img.src = withCacheBuster(urls[i]);
          }
        });
      }

      function jsonp(url, timeoutMs=12000){
        return new Promise((resolve, reject) => {
          const cbName = "__reelCb_" + Math.random().toString(36).slice(2);
          const u = new URL(url);

          // Add jsonp params
          u.searchParams.set("format", "jsonp");
          u.searchParams.set("callback", cbName);

          const s = document.createElement("script");
          s.async = true;
          s.src = u.toString();

          let timer = null;

          window[cbName] = (data) => {
            cleanup();
            resolve(data);
          };

          function cleanup(){
            if (timer) window.clearTimeout(timer);
            try { delete window[cbName]; } catch(_) { window[cbName] = undefined; }
            if (s && s.parentNode) s.parentNode.removeChild(s);
          }

          s.onerror = () => {
            cleanup();
            reject(new Error("Failed to load API (script error)."));
          };

          timer = window.setTimeout(() => {
            cleanup();
            reject(new Error("API timeout."));
          }, timeoutMs);

          document.head.appendChild(s);
        });
      }

      function buildApiUrl(){
        if (!api) return "";

        // api is expected to be something like:
        // https://script.google.com/macros/s/.../exec?r=api_photo_reel
        // We append bot/date/w/cache_s here.
        const u = new URL(api);

        if (bot) u.searchParams.set("bot", bot);
        if (dateKey) u.searchParams.set("date", dateKey);

        // Optional: server may use w for thumb sizing
        u.searchParams.set("w", String(w));

        // Optional: cache hint (server-side)
        u.searchParams.set("cache_s", String(cache_s));

        return u.toString();
      }

      async function init(){
        setPlayIcon(false);

        if (!bot || !dateKey){
          showEmpty(
            "Missing params",
            "Need bot and date",
            "Example: ?bot=winston&date=2025-12-20"
          );
          updateDisabledButtons();
          return;
        }

        if (!api){
          showEmpty(
            "Missing api",
            "Pass api=your api_photo_reel url in the query string.",
            "Example: ?api=https%3A%2F%2Fscript.google.com%2Fmacros%2Fs%2F...%2Fexec%3Fr%3Dapi_photo_reel&bot=winston&date=2025-12-20"
          );
          updateDisabledButtons();
          return;
        }

        hideEmpty();

        const apiUrl = buildApiUrl();
        let data;
        try{
          data = await jsonp(apiUrl, 15000);
        }catch(err){
          showEmpty("No photos", `${dateKey} • ${bot}`, String(err && err.message ? err.message : err));
          updateDisabledButtons();
          return;
        }

        // Expect shape: { ok, dateKey, bot, photos:[...], error? }
        const ok = !!(data && (data.ok === true || data.ok === "true"));
        const arr = (data && (data.photos || data.photoUrls || data.urls)) || [];
        const errMsg = data && (data.error || data.err || "");

        photos = Array.isArray(arr) ? arr.map(x => String(x||"").trim()).filter(Boolean) : [];
        if (!ok && !photos.length){
          showEmpty("No photos", `${dateKey} • ${bot}`, errMsg ? String(errMsg) : "API returned ok=false");
          updateDisabledButtons();
          return;
        }
        if (!photos.length){
          showEmpty("No photos", `${dateKey} • ${bot}`, errMsg ? String(errMsg) : "");
          updateDisabledButtons();
          return;
        }

        // Build non-repeating order
        order = buildOrder();
        orderPos = 0;

        // Preload first N in display order
        const preloadUrls = order.slice(0, Math.min(preloadN, order.length)).map(i => photos[i]);
        await preloadSome(preloadUrls, preloadN);

        // Initial render
        renderToCurrent();

        // If only one photo, pause state and disable controls accordingly
        updateDisabledButtons();
        if (photos.length <= 1){
          isPaused = true;
          setPlayIcon(true);
        } else {
          isPaused = false;
          setPlayIcon(false);
          startTimer();
        }

        // Controls are hover-only, but give a brief hint on load
        showControls(1600);
      }

      init();
    })();
  </script>
</body>
</html>


<!doctype html>
<!--
reel.html
LifeLog Photo Reel (GitHub Pages)

Behavior updates in this version:
  ✅ Default UI hidden (controls + dots + tag hidden until hover/tap)
  ✅ When there are NO photos, the entire frame stays transparent so the Garden sky shows through,
     with a small centered badge: "No photos for the day"
  ✅ Non-repeating shuffle (no repeats until all shown)
  ✅ Controls appear on hover/move/tap, then auto-hide (faster while playing, longer when paused)
  ✅ Disable Prev/Next when only 1 photo
  ✅ Classy preload progress bar
  ✅ Subtle crossfade easing
  ✅ Background blur layer (helps portrait shots feel framed)

Expected URL params (examples):
  reel.html?api=<ENCODED_API_URL>&bot=winston&date=2025-12-20&fit=contain&w=1200&preload=2&cache_s=600&interval_ms=2200&fade_ms=450&shuffle=1

Notes:
- Keyboard support intentionally NOT included.
- The api should return JSON like: { ok:true, dateKey:"YYYY-MM-DD", photos:["https://...","https://..."] }
-->

<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);

      --radius: 14px;
      --hudPad: 10px;

      --ctrlBg: rgba(0,0,0,0.38);
      --ctrlRing: rgba(255,255,255,0.22);

      --barBg: rgba(255,255,255,0.14);
      --barFg: rgba(255,255,255,0.72);
    }

    html, body { height:100%; margin:0; background: transparent; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    .frame{
      position:relative;
      width:100%;
      height:100%;
      border-radius: var(--radius);
      overflow:hidden;
      background: transparent;
    }

    .bg{
      position:absolute;
      inset:0;
      background-size: cover;
      background-position: center;
      filter: blur(24px) saturate(1.05);
      transform: scale(1.12);
      opacity: 0;
      transition: opacity 420ms ease;
      pointer-events:none;
    }
    .bg.on{ opacity: 1; }

    .vignette{
      position:absolute;
      inset:0;
      opacity: 0;
      transition: opacity 300ms ease;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.08), rgba(0,0,0,0.45));
      pointer-events:none;
    }
    .vignette.on{ opacity: 1; }

    .img{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      opacity:0;
      transition: opacity var(--fadeMs, 450ms) cubic-bezier(.22,.61,.36,1);
      will-change: opacity;
      object-fit: var(--fit, contain);
      pointer-events:none;
    }
    .img.on{ opacity: 1; }

    .tag{
      position:absolute;
      top: var(--hudPad);
      left: var(--hudPad);
      z-index: 10;
      font-size: 11px;
      color: var(--text);
      padding: 5px 9px;
      border-radius: 999px;
      background: rgba(0,0,0,0.34);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: calc(100% - 2*var(--hudPad));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;
      opacity: 0;
      transition: opacity 220ms ease;
    }

    .dots{
      position:absolute;
      left:50%;
      bottom: calc(var(--hudPad) + 58px);
      transform: translateX(-50%);
      display:flex;
      gap: 6px;
      z-index: 10;
      pointer-events:none;
      opacity: 0;
      transition: opacity 220ms ease;
    }
    .dot{
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.32);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.10);
    }
    .dot.on{ background: rgba(255,255,255,0.78); }

    .progress{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      width: min(220px, 62vw);
      z-index: 11;
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events:none;
    }
    .progress.on{ opacity: 1; }
    .progress .label{
      font-size: 12px;
      color: var(--muted);
      text-align:center;
      margin-bottom: 8px;
      letter-spacing: 0.2px;
      text-shadow: 0 1px 8px rgba(0,0,0,0.35);
    }
    .progress .bar{
      height: 6px;
      border-radius: 999px;
      background: var(--barBg);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }
    .progress .fill{
      height: 100%;
      width: 0%;
      background: var(--barFg);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    .empty{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 12;
      background: transparent;
      pointer-events:none;
    }
    .empty .badge{
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.20);
      max-width: min(240px, 78vw);
      text-align:center;
      line-height: 1.25;
    }
    .empty .sub{
      margin-top: 6px;
      font-size: 11px;
      color: rgba(255,255,255,0.62);
    }

    .controls{
      position:absolute;
      left:50%;
      bottom: calc(var(--hudPad) + 12px);
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: clamp(8px, 2.2vw, 14px);
      padding: clamp(6px, 1.6vw, 10px);
      border-radius: 999px;
      background: var(--ctrlBg);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      z-index: 10;
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    .controls.on{
      opacity: 1;
      pointer-events: auto;
    }

    .btn{
      width: clamp(26px, 6vw, 38px);
      height: clamp(26px, 6vw, 38px);
      border-radius: 999px;
      border: 1px solid var(--ctrlRing);
      background: rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: scale(0.96); }

    .btn svg{
      width: clamp(12px, 3.2vw, 18px);
      height: clamp(12px, 3.2vw, 18px);
      fill: none;
      stroke: rgba(255,255,255,0.86);
      stroke-width: 2.2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .btn.main{
      width: clamp(30px, 7vw, 42px);
      height: clamp(30px, 7vw, 42px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.26);
    }
    .btn.main svg{
      width: clamp(14px, 3.6vw, 20px);
      height: clamp(14px, 3.6vw, 20px);
    }

    .btn.disabled{
      opacity: 0.35;
      cursor: default;
      pointer-events: none;
    }

    .hotzone{
      position:absolute;
      inset:0;
      z-index: 7;
      background: transparent;
    }

    .uiOn .tag,
    .uiOn .dots{ opacity: 1; }
  </style>
</head>

<body>
  <div class="frame" id="frame">
    <div class="bg" id="bg"></div>
    <div class="vignette" id="vignette"></div>
    <div class="hotzone" id="hotzone"></div>

    <div class="tag" id="tag" style="display:none;"></div>
    <div class="dots" id="dots" style="display:none;"></div>

    <div class="progress" id="progress" style="display:none;">
      <div class="label" id="progressLabel">loading photos…</div>
      <div class="bar"><div class="fill" id="progressFill"></div></div>
    </div>

    <div class="controls" id="controls" aria-label="controls">
      <div class="btn" id="btnPrev" title="Previous" aria-label="Previous">
        <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
      </div>

      <div class="btn main" id="btnPlay" title="Play/Pause" aria-label="Play/Pause">
        <svg id="iconPlay" viewBox="0 0 24 24"><path d="M9 8l10 4-10 4z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" style="display:none;">
          <path d="M8 6v12"/><path d="M16 6v12"/>
        </svg>
      </div>

      <div class="btn" id="btnNext" title="Next" aria-label="Next">
        <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg>
      </div>
    </div>
  </div>

  <script>
    const qs = new URLSearchParams(location.search);
    const apiBase = qs.get('api') || '';
    const bot = qs.get('bot') || 'winston';
    const date = qs.get('date') || '';

    const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';
    const fadeMs = clampInt(qs.get('fade_ms'), 450, 150, 2500);
    const intervalMs = clampInt(qs.get('interval_ms'), 2200, 700, 20000);
    const preloadN = clampInt(qs.get('preload'), 2, 0, 12);
    const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
    const shuffle = (qs.get('shuffle') || '1') !== '0';
    const wParam = qs.get('w');

    const HIDE_MS_PLAYING = 1200;
    const HIDE_MS_PAUSED  = 3600;

    document.documentElement.style.setProperty('--fit', fit);
    document.documentElement.style.setProperty('--fadeMs', fadeMs + 'ms');

    const frame = document.getElementById('frame');
    const bg = document.getElementById('bg');
    const vignette = document.getElementById('vignette');
    const tag = document.getElementById('tag');
    const dotsEl = document.getElementById('dots');

    const progress = document.getElementById('progress');
    const progressLabel = document.getElementById('progressLabel');
    const progressFill = document.getElementById('progressFill');

    const controls = document.getElementById('controls');
    const hotzone = document.getElementById('hotzone');

    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnPlay = document.getElementById('btnPlay');
    const iconPlay = document.getElementById('iconPlay');
    const iconPause = document.getElementById('iconPause');

    let photos = [];
    let ok = [];
    let imgs = [];
    let started = false;

    let deck = [];
    let deckPos = 0;

    let idx = 0;
    let timer = null;
    let isPlaying = true;
    let hideT = null;

    function clampInt(v, def, min, max){
      const n = Number(v);
      if (!Number.isFinite(n)) return def;
      return Math.max(min, Math.min(max, Math.round(n)));
    }

    function safeText(s){
      return String(s || '').replace(/[<>]/g,'');
    }

    function showEmptyTransparent(message, sub){
      const d = document.createElement('div');
      d.className = 'empty';
      d.innerHTML =
        '<div class="badge">' +
          safeText(message || 'No photos for the day') +
          (sub ? ('<div class="sub">' + safeText(sub) + '</div>') : '') +
        '</div>';
      frame.appendChild(d);
    }

    function showProgress(on, label){
      if (!on){
        progress.classList.remove('on');
        progress.style.display = 'none';
        return;
      }
      progress.style.display = '';
      if (label) progressLabel.textContent = label;
      requestAnimationFrame(() => progress.classList.add('on'));
    }

    function setProgress(pct){
      const p = Math.max(0, Math.min(100, pct));
      progressFill.style.width = p + '%';
    }

    function setUiVisible(on){
      if (on){
        controls.classList.add('on');
        frame.classList.add('uiOn');
      } else {
        controls.classList.remove('on');
        frame.classList.remove('uiOn');
      }
    }

    function showControls(){
      setUiVisible(true);
      scheduleHideControls();
    }

    function scheduleHideControls(){
      if (hideT) clearTimeout(hideT);
      const ms = isPlaying ? HIDE_MS_PLAYING : HIDE_MS_PAUSED;
      hideT = setTimeout(() => setUiVisible(false), ms);
    }

    function syncPlayIcon(){
      if (isPlaying){
        iconPlay.style.display = 'none';
        iconPause.style.display = '';
      } else {
        iconPlay.style.display = '';
        iconPause.style.display = 'none';
      }
    }

    function disablePrevNextIfNeeded(){
      const one = (ok.length <= 1);
      if (one){
        btnPrev.classList.add('disabled');
        btnNext.classList.add('disabled');
      } else {
        btnPrev.classList.remove('disabled');
        btnNext.classList.remove('disabled');
      }
    }

    function setTag(text){
      tag.textContent = text;
      tag.style.display = '';
    }

    function buildDots(count){
      if (!count || count <= 1){
        dotsEl.style.display = 'none';
        dotsEl.innerHTML = '';
        return;
      }
      dotsEl.style.display = '';
      dotsEl.innerHTML = '';
      for (let i = 0; i < count; i++){
        const d = document.createElement('div');
        d.className = 'dot' + (i === idx ? ' on' : '');
        dotsEl.appendChild(d);
      }
    }

    function updateDots(){
      const dots = dotsEl.querySelectorAll('.dot');
      if (!dots || !dots.length) return;
      dots.forEach((d, i) => {
        if (i === idx) d.classList.add('on');
        else d.classList.remove('on');
      });
    }

    function buildApiUrl(){
      if (!apiBase) return '';
      const u = new URL(apiBase, location.href);
      if (bot) u.searchParams.set('bot', bot);
      if (date) u.searchParams.set('date', date);
      if (wParam) u.searchParams.set('w', wParam);
      if (cacheS) u.searchParams.set('cache_s', String(cacheS));
      return u.toString();
    }

    async function fetchJson(url){
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      return await resp.json();
    }

    function shuffleArray(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function resetDeck(currentIndex){
      const indices = ok.map((_, i) => i);
      let shuffled = shuffle ? shuffleArray(indices) : indices;
      if (shuffle && ok.length > 1 && shuffled[0] === currentIndex){
        const swapWith = 1 + Math.floor(Math.random() * (shuffled.length - 1));
        [shuffled[0], shuffled[swapWith]] = [shuffled[swapWith], shuffled[0]];
      }
      deck = shuffled;
      deckPos = 0;
    }

    function nextFromDeck(){
      if (ok.length <= 1) return 0;
      if (!deck.length || deckPos >= deck.length){
        resetDeck(idx);
      }
      if (ok.length > 1 && deck[deckPos] === idx){
        deckPos++;
        if (deckPos >= deck.length){
          resetDeck(idx);
        }
      }
      const ni = deck[deckPos];
      deckPos++;
      return ni;
    }

    function prevIndexSimple(){
      if (ok.length <= 1) return 0;
      return (idx - 1 + ok.length) % ok.length;
    }

    function setBgFor(src){
      bg.style.backgroundImage = 'url("' + src + '")';
      bg.classList.add('on');
      vignette.classList.add('on');
    }

    function showIndex(i){
      if (!imgs.length) return;
      const prev = idx;
      idx = i;

      if (imgs[prev]) imgs[prev].classList.remove('on');
      if (imgs[idx]) imgs[idx].classList.add('on');

      setBgFor(ok[idx]);
      updateDots();
    }

    function stopTimer(){
      if (timer) clearInterval(timer);
      timer = null;
    }

    function startTimer(){
      stopTimer();
      if (!isPlaying) return;
      if (ok.length <= 1) return;
      timer = setInterval(() => {
        const ni = nextFromDeck();
        showIndex(ni);
      }, Math.max(300, intervalMs));
    }

    function wireControls(){
      setUiVisible(false);

      hotzone.addEventListener('click', () => showControls());
      frame.addEventListener('pointermove', () => showControls(), { passive: true });
      frame.addEventListener('pointerenter', () => showControls(), { passive: true });

      btnPlay.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();

        isPlaying = !isPlaying;
        syncPlayIcon();
        startTimer();
      });

      btnNext.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();
        if (!started || ok.length <= 1) return;
        showIndex(nextFromDeck());
      });

      btnPrev.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();
        if (!started || ok.length <= 1) return;
        showIndex(prevIndexSimple());
      });
    }

    function preloadImage(src){
      return new Promise((resolve) => {
        const im = new Image();
        im.decoding = 'async';
        im.loading = 'eager';
        im.onload = () => resolve({ ok:true, src });
        im.onerror = () => resolve({ ok:false, src });
        im.src = src;
      });
    }

    async function primeFirstThenBackground(){
      const total = photos.length;
      ok = [];

      if (preloadN > 0){
        showProgress(true, 'loading photos…');
        setProgress(0);
      }

      const first = await preloadImage(photos[0]);
      if (first.ok) ok.push(first.src);

      if (preloadN > 0){
        setProgress(Math.round((1 / total) * 100));
      }

      let loaded = 1;
      const tasks = [];
      for (let i = 1; i < total; i++){
        tasks.push((async () => {
          const r = await preloadImage(photos[i]);
          loaded++;
          if (preloadN > 0){
            setProgress(Math.round((loaded / total) * 100));
          }
          if (r.ok) ok.push(r.src);
        })());
      }

      if (preloadN > 0){
        const need = Math.min(total, Math.max(1, preloadN));
        await Promise.race([
          Promise.allSettled(tasks.slice(0, Math.max(0, need - 1))),
          new Promise(res => setTimeout(res, 2000))
        ]);
        showProgress(false);
      }

      Promise.allSettled(tasks).then(() => {
        // ok[] may grow, but we keep it simple and don't add DOM layers late.
        // If you want late-added photos to be eligible for shuffle immediately,
        // we can switch to a 2-image swapper architecture later.
      });
    }

    function buildLayers(){
      imgs = ok.map((src, i) => {
        const im = document.createElement('img');
        im.className = 'img';
        im.alt = 'photo ' + (i + 1);
        im.decoding = 'async';
        im.loading = (i === 0) ? 'eager' : 'lazy';
        im.src = src;
        frame.appendChild(im);
        return im;
      });

      resetDeck(0);

      idx = 0;
      if (imgs[0]) imgs[0].classList.add('on');
      setBgFor(ok[0]);

      buildDots(ok.length);

      started = true;
      disablePrevNextIfNeeded();
      syncPlayIcon();
      startTimer();
    }

    async function main(){
      wireControls();

      const apiUrl = buildApiUrl();
      if (!apiUrl){
        showEmptyTransparent('Missing api', 'pass api=... in the url');
        return;
      }

      try{
        const data = await fetchJson(apiUrl);
        if (!data || !data.ok){
          const err = (data && data.error) ? String(data.error) : 'API returned not ok';
          showEmptyTransparent('No photos for the day', err);
          return;
        }

        const dateKey = data.dateKey || date || '';
        const count = Array.isArray(data.photos) ? data.photos.length : 0;

        setTag((dateKey ? dateKey : 'date') + ' • ' + bot);

        if (!count){
          showEmptyTransparent('No photos for the day', (dateKey ? dateKey : '') + (bot ? (' • ' + bot) : ''));
          return;
        }

        photos = data.photos.slice();
        await primeFirstThenBackground();

        if (!ok.length){
          showEmptyTransparent('No photos for the day', 'photos exist but could not be loaded (permissions or invalid urls).');
          return;
        }

        buildLayers();

      } catch (e){
        showEmptyTransparent('No photos for the day', 'failed to load: ' + String(e && e.message ? e.message : e));
      }
    }

    main();
  </script>
</body>
</html>

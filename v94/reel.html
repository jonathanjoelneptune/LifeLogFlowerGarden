<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --r: 12px;
      --hud-bg: rgba(0,0,0,0.35);
      --hud-fg: rgba(255,255,255,0.92);
      --hud-fg-dim: rgba(255,255,255,0.70);
      --btn-bg: rgba(0,0,0,0.40);
      --btn-bg-hover: rgba(0,0,0,0.60);
      --btn-fg: rgba(255,255,255,0.90);
      --dot-off: rgba(255,255,255,0.35);
      --dot-on: rgba(255,255,255,0.90);
      --blur: 18px;
    }

    html, body { height: 100%; margin: 0; background: transparent; }
    body { overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    /* Edge-to-edge in skybox */
    .stage{
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--r);
      overflow: hidden;
      background: rgba(0,0,0,0.08);
    }

    /* Blurred background layer */
    .bg{
      position:absolute;
      inset:-16px; /* expand to avoid blur edges */
      background-position:center;
      background-size:cover;
      filter: blur(var(--blur));
      transform: scale(1.08);
      opacity: 0.85;
    }
    .bg::after{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.10), rgba(0,0,0,0.35));
    }

    /* Foreground image layers */
    .imgLayer{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .imgLayer img{
      width: 100%;
      height: 100%;
      object-fit: contain; /* default; can switch to cover */
      opacity: 0;
      transition: opacity 900ms cubic-bezier(.2,.9,.2,1);
      will-change: opacity;
      user-select:none;
      -webkit-user-drag:none;
    }
    .imgLayer img.show{ opacity: 1; }

    /* Tiny classy preload bar */
    .preloadWrap{
      position:absolute;
      left: 10px;
      right: 10px;
      top: 10px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      overflow:hidden;
      opacity: 0;
      transition: opacity 300ms ease;
      pointer-events:none;
    }
    .preloadWrap.on{ opacity: 1; }
    .preloadBar{
      height: 100%;
      width: 0%;
      background: rgba(255,255,255,0.75);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    /* HUD: created once; fades away */
    .hud{
      position:absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--hud-bg);
      color: var(--hud-fg);
      font-size: 11px;
      line-height: 1;
      backdrop-filter: blur(8px);
      max-width: calc(100% - 20px);
      box-sizing:border-box;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 350ms ease, transform 350ms ease;
      pointer-events:none;
    }
    .hud.show{
      opacity: 1;
      transform: translateY(0px);
    }
    .hud .dim{ color: var(--hud-fg-dim); }

    /* Dots */
    .dots{
      position:absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      display:flex;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.22);
      backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 250ms ease;
      pointer-events:none;
    }
    .dots.show{ opacity: 1; }
    .dot{
      width: 6px; height: 6px;
      border-radius: 999px;
      background: var(--dot-off);
    }
    .dot.on{ background: var(--dot-on); }

    /* Controls appear on hover */
    .controls{
      position:absolute;
      right: 10px;
      bottom: 10px;
      display:flex;
      gap: 8px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events:none; /* enabled on hover */
    }
    .stage:hover .controls{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .btn{
      border: none;
      background: var(--btn-bg);
      color: var(--btn-fg);
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      padding: 0;
      width: clamp(22px, 3.8vw, 34px);
      height: clamp(22px, 3.8vw, 34px);
      backdrop-filter: blur(8px);
      transition: background 160ms ease, opacity 160ms ease, transform 160ms ease;
    }
    .btn:hover{ background: var(--btn-bg-hover); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn:disabled{
      opacity: 0.35;
      cursor: default;
      transform: none;
    }
    .icon{
      width: clamp(12px, 2.2vw, 16px);
      height: clamp(12px, 2.2vw, 16px);
      display:block;
    }

    /* Empty state */
    .empty{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 16px;
      box-sizing:border-box;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.30);
    }
    .empty .card{
      max-width: 360px;
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 14px 14px;
      box-sizing:border-box;
    }
    .empty .title{ font-weight: 700; font-size: 14px; }
    .empty .sub{ margin-top: 8px; font-size: 12px; color: rgba(255,255,255,0.75); line-height: 1.35; }
    .empty .tiny{ margin-top: 10px; font-size: 11px; color: rgba(255,255,255,0.65); line-height: 1.35; }
    .empty a{ color: rgba(255,255,255,0.9); }

  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="bg" id="bg"></div>

    <div class="preloadWrap" id="preloadWrap"><div class="preloadBar" id="preloadBar"></div></div>

    <div class="imgLayer" id="layerA"><img id="imgA" alt=""></div>
    <div class="imgLayer" id="layerB"><img id="imgB" alt=""></div>

    <div class="hud" id="hud"></div>
    <div class="dots" id="dots"></div>

    <div class="controls" id="controls">
      <button class="btn" id="btnPrev" title="Previous" aria-label="Previous">
        <svg class="icon" viewBox="0 0 24 24" fill="none">
          <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="btn" id="btnPlay" title="Pause" aria-label="Pause">
        <svg class="icon" id="iconPause" viewBox="0 0 24 24" fill="none">
          <path d="M9 7v10M15 7v10" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
        </svg>
        <svg class="icon" id="iconPlay" viewBox="0 0 24 24" fill="none" style="display:none;">
          <path d="M10 8l8 4-8 4V8z" fill="currentColor"/>
        </svg>
      </button>
      <button class="btn" id="btnNext" title="Next" aria-label="Next">
        <svg class="icon" viewBox="0 0 24 24" fill="none">
          <path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>
  </div>

<script>
(function(){
  const qs = new URLSearchParams(location.search);

  const api = qs.get('api') || '';
  const bot = qs.get('bot') || 'winston';
  const date = qs.get('date') || '';
  const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';

  const intervalMs = clampInt(qs.get('interval_ms'), 2200, 500, 60000);
  const fadeMs = clampInt(qs.get('fade_ms'), 1000, 150, 8000);
  const preloadN = clampInt(qs.get('preload'), 2, 0, 24);
  const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
  const shuffle = (qs.get('shuffle') || '0') === '1' || (qs.get('shuffle') || '').toLowerCase() === 'true';

  const stage = document.getElementById('stage');
  const bg = document.getElementById('bg');

  const preloadWrap = document.getElementById('preloadWrap');
  const preloadBar = document.getElementById('preloadBar');

  const imgA = document.getElementById('imgA');
  const imgB = document.getElementById('imgB');

  const hud = document.getElementById('hud');
  const dots = document.getElementById('dots');

  const btnPrev = document.getElementById('btnPrev');
  const btnPlay = document.getElementById('btnPlay');
  const btnNext = document.getElementById('btnNext');
  const iconPause = document.getElementById('iconPause');
  const iconPlay = document.getElementById('iconPlay');

  // Apply fit + fade duration
  imgA.style.objectFit = fit;
  imgB.style.objectFit = fit;
  imgA.style.transitionDuration = fadeMs + 'ms';
  imgB.style.transitionDuration = fadeMs + 'ms';

  function clampInt(v, def, min, max){
    const n = Number(v);
    if (!isFinite(n)) return def;
    return Math.max(min, Math.min(max, Math.round(n)));
  }

  function showHud(text, mode){
    // mode: "playing" (short) or "paused" (long)
    hud.textContent = text;
    hud.classList.add('show');
    const ttl = (mode === 'paused') ? 3500 : 1300;
    clearTimeout(showHud._t);
    showHud._t = setTimeout(()=>hud.classList.remove('show'), ttl);
  }

  function setProgress(p){
    const pct = Math.max(0, Math.min(100, Math.round(p * 100)));
    preloadBar.style.width = pct + '%';
  }

  function setPreloadVisible(on){
    preloadWrap.classList.toggle('on', !!on);
  }

  function escapeHtml(s){
    return String(s||'')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  function renderEmpty(title, sub, tiny){
    stage.innerHTML = `
      <div class="empty">
        <div class="card">
          <div class="title">${escapeHtml(title)}</div>
          <div class="sub">${escapeHtml(sub || '')}</div>
          ${tiny ? `<div class="tiny">${tiny}</div>` : ``}
        </div>
      </div>`;
  }

  // Build API URL
  function buildApiUrl(){
    if (!api) return '';
    const u = new URL(api);
    u.searchParams.set('bot', bot);
    if (date) u.searchParams.set('date', date);
    u.searchParams.set('format', 'json');
    if (cacheS > 0) u.searchParams.set('cache_s', String(cacheS));
    // cache buster to avoid GitHub cache sticking during dev; keep stable when cache_s>0
    if (cacheS === 0) u.searchParams.set('_t', String(Date.now()));
    return u.toString();
  }

  // PRELOAD helpers
  function preloadOne(url){
    return new Promise((resolve) => {
      const im = new Image();
      im.decoding = 'async';
      im.onload = () => resolve(true);
      im.onerror = () => resolve(false);
      im.src = url;
    });
  }

  // Shuffle without repeats until all shown (cycle bag)
  function makeCycleOrder(n){
    const arr = Array.from({length:n}, (_,i)=>i);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  let photos = [];
  let order = [];
  let orderPos = 0;
  let idx = 0;

  let usingA = true;
  let playing = true;
  let timer = null;

  function updateDots(activeIndex){
    if (photos.length <= 1){
      dots.classList.remove('show');
      dots.innerHTML = '';
      return;
    }
    dots.classList.add('show');
    if (!dots._built){
      dots.innerHTML = '';
      for (let i=0;i<photos.length;i++){
        const d = document.createElement('div');
        d.className = 'dot';
        dots.appendChild(d);
      }
      dots._built = true;
    }
    const kids = dots.children;
    for (let i=0;i<kids.length;i++){
      kids[i].classList.toggle('on', i === activeIndex);
    }
  }

  function setControlsDisabled(){
    const one = photos.length <= 1;
    btnPrev.disabled = one;
    btnNext.disabled = one;
  }

  function setPlayIcon(){
    if (playing){
      iconPause.style.display = '';
      iconPlay.style.display = 'none';
      btnPlay.title = 'Pause';
      btnPlay.setAttribute('aria-label', 'Pause');
    } else {
      iconPause.style.display = 'none';
      iconPlay.style.display = '';
      btnPlay.title = 'Play';
      btnPlay.setAttribute('aria-label', 'Play');
    }
  }

  function bgFor(url){
    bg.style.backgroundImage = `url("${url}")`;
  }

  function crossfadeTo(url, nextIdx){
    const show = usingA ? imgB : imgA;
    const hide = usingA ? imgA : imgB;

    // Prepare new image in hidden layer, then fade
    show.classList.remove('show');
    show.src = url;
    show.alt = `photo ${nextIdx + 1}`;

    // Ensure it has a frame to apply opacity transition
    requestAnimationFrame(() => {
      // Fade in new, fade out old
      hide.classList.remove('show');
      show.classList.add('show');
      usingA = !usingA;
    });

    // Update blurred background immediately (looks smoother)
    bgFor(url);

    updateDots(nextIdx);
  }

  function nextIndex(){
    if (photos.length <= 1) return 0;

    if (shuffle){
      if (!order.length || orderPos >= order.length){
        order = makeCycleOrder(photos.length);
        // Avoid repeating the same image across cycle boundary if possible
        if (order.length > 1 && order[0] === idx){
          const swapWith = 1 + Math.floor(Math.random() * (order.length - 1));
          [order[0], order[swapWith]] = [order[swapWith], order[0]];
        }
        orderPos = 0;
      }
      const ni = order[orderPos++];
      return ni;
    }

    return (idx + 1) % photos.length;
  }

  function prevIndex(){
    if (photos.length <= 1) return 0;
    if (shuffle){
      // In shuffle mode, "prev" goes to last shown by tracking a small history
      if (prevIndex._hist && prevIndex._hist.length >= 2){
        // Current idx is last element; go to prior
        prevIndex._hist.pop();
        const p = prevIndex._hist[prevIndex._hist.length - 1];
        return (typeof p === 'number') ? p : idx;
      }
      return idx;
    }
    return (idx - 1 + photos.length) % photos.length;
  }

  function rememberHistory(i){
    if (!shuffle) return;
    if (!prevIndex._hist) prevIndex._hist = [];
    const h = prevIndex._hist;
    if (!h.length || h[h.length - 1] !== i) h.push(i);
    if (h.length > 200) h.splice(0, h.length - 200);
  }

  function stepTo(i, reason){
    if (!photos[i]) return;

    idx = i;
    rememberHistory(i);

    // Crossfade
    crossfadeTo(photos[i], i);

    // Quiet HUD: show once on start, and on user actions
    if (reason === 'init'){
      showHud(`${date || ''}  \u2022  ${bot}  \u2022  ${photos.length} photos`, 'playing');
    } else if (reason === 'user'){
      showHud(`${idx + 1} <span class="dim">/</span> ${photos.length}`, playing ? 'playing' : 'paused');
    }
  }

  function startTimer(){
    stopTimer();
    if (!playing) return;
    if (photos.length <= 1) return;

    timer = setInterval(() => {
      const ni = nextIndex();
      stepTo(ni, 'auto');
    }, intervalMs);
  }

  function stopTimer(){
    if (timer){ clearInterval(timer); timer = null; }
  }

  // User controls
  btnNext.addEventListener('click', () => {
    if (photos.length <= 1) return;
    const ni = nextIndex();
    stepTo(ni, 'user');
    startTimer();
  });

  btnPrev.addEventListener('click', () => {
    if (photos.length <= 1) return;
    const pi = prevIndex();
    stepTo(pi, 'user');
    startTimer();
  });

  btnPlay.addEventListener('click', () => {
    playing = !playing;
    setPlayIcon();
    if (playing){
      showHud(`${idx + 1} / ${photos.length}`, 'playing');
      startTimer();
    } else {
      stopTimer();
      showHud(`${idx + 1} / ${photos.length}`, 'paused');
    }
  });

  // Load + init
  (async function init(){
    if (!api){
      renderEmpty('Missing api', 'Pass api=your api_photo_reel url in the query string.', '');
      return;
    }

    const url = buildApiUrl();
    let json = null;

    try{
      const res = await fetch(url, { cache: 'no-store' });
      json = await res.json();
    }catch(e){
      renderEmpty('Could not load', 'API fetch failed', 'Check that api_photo_reel returns JSON and is publicly accessible.');
      return;
    }

    if (!json || !json.ok){
      renderEmpty('No photos', `${date || ''} • ${bot}`, (json && json.error) ? String(json.error) : 'API returned an error.');
      return;
    }

    photos = Array.isArray(json.photos) ? json.photos.filter(Boolean) : [];
    if (!photos.length){
      renderEmpty('No photos', `${json.dateKey || date || ''} • ${bot}`, '');
      return;
    }

    // Preload first + next N (tiny progress bar)
    setPreloadVisible(preloadN > 0);
    const toPreload = [0];
    for (let i=1; i<=preloadN; i++){
      if (i < photos.length) toPreload.push(i);
    }

    let done = 0;
    const total = toPreload.length;
    for (const k of toPreload){
      await preloadOne(photos[k]);
      done++;
      setProgress(done / total);
    }
    setTimeout(() => setPreloadVisible(false), 450);

    // Init first frame
    // Put first photo into A, show it, B hidden
    imgA.src = photos[0];
    imgA.alt = 'photo 1';
    imgB.src = '';
    imgA.classList.add('show');
    imgB.classList.remove('show');
    usingA = true;

    bgFor(photos[0]);

    // Dots + controls
    dots._built = false;
    updateDots(0);
    setControlsDisabled();

    // Shuffle cycle init: ensure we don't repeat immediately
    if (shuffle){
      order = makeCycleOrder(photos.length);
      if (order.length > 1 && order[0] === 0){
        [order[0], order[1]] = [order[1], order[0]];
      }
      orderPos = 0;
      prevIndex._hist = [0];
    }

    playing = true;
    setPlayIcon();
    stepTo(0, 'init');
    startTimer();

  })();

})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --r: 12px;
      --hud-bg: rgba(0,0,0,0.35);
      --hud-fg: rgba(255,255,255,0.92);
      --hud-fg-dim: rgba(255,255,255,0.70);
      --btn-bg: rgba(0,0,0,0.40);
      --btn-bg-hover: rgba(0,0,0,0.60);
      --btn-fg: rgba(255,255,255,0.90);
      --dot-off: rgba(255,255,255,0.35);
      --dot-on: rgba(255,255,255,0.90);
      --blur: 18px;
    }

    html, body { height: 100%; margin: 0; background: transparent; }
    body { overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    .stage{
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--r);
      overflow: hidden;
      background: rgba(0,0,0,0.08);
    }

    /* Blurred background */
    .bg{
      position:absolute;
      inset:-16px;
      background-position:center;
      background-size:cover;
      filter: blur(var(--blur));
      transform: scale(1.08);
      opacity: 0.85;
    }
    .bg::after{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.10), rgba(0,0,0,0.35));
    }

    /* Foreground image (single element fade logic) */
    .img{
      position:absolute;
      inset:0;
      width: 100%;
      height: 100%;
      object-fit: contain; /* default; may switch to cover */
      opacity: 0;
      transition: opacity 900ms ease-in-out;
      will-change: opacity;
      user-select:none;
      -webkit-user-drag:none;
    }
    .img.show{ opacity: 1; }

    /* Tiny classy preload bar */
    .preloadWrap{
      position:absolute;
      left: 10px;
      right: 10px;
      top: 10px;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      overflow:hidden;
      opacity: 0;
      transition: opacity 300ms ease;
      pointer-events:none;
    }
    .preloadWrap.on{ opacity: 1; }
    .preloadBar{
      height: 100%;
      width: 0%;
      background: rgba(255,255,255,0.75);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    /* UI group: hud + dots + controls */
    .ui{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .hud{
      position:absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--hud-bg);
      color: var(--hud-fg);
      font-size: 11px;
      line-height: 1;
      backdrop-filter: blur(8px);
      max-width: calc(100% - 20px);
      box-sizing:border-box;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 350ms ease, transform 350ms ease;
    }
    .hud.show{
      opacity: 1;
      transform: translateY(0px);
    }

    .dots{
      position:absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      display:flex;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.22);
      backdrop-filter: blur(8px);
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 350ms ease, transform 350ms ease;
    }
    .dots.show{ opacity: 1; transform: translateY(0); }
    .dot{
      width: 6px; height: 6px;
      border-radius: 999px;
      background: var(--dot-off);
    }
    .dot.on{ background: var(--dot-on); }

    /* Controls appear on hover */
    .controls{
      position:absolute;
      right: 10px;
      bottom: 10px;
      display:flex;
      gap: 8px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events:none;
    }
    .stage:hover .controls{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }

    .btn{
      border: none;
      background: var(--btn-bg);
      color: var(--btn-fg);
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      padding: 0;
      width: clamp(22px, 3.8vw, 34px);
      height: clamp(22px, 3.8vw, 34px);
      backdrop-filter: blur(8px);
      transition: background 160ms ease, opacity 160ms ease, transform 160ms ease;
    }
    .btn:hover{ background: var(--btn-bg-hover); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn:disabled{
      opacity: 0.35;
      cursor: default;
      transform: none;
    }
    .icon{
      width: clamp(12px, 2.2vw, 16px);
      height: clamp(12px, 2.2vw, 16px);
      display:block;
    }

    /* Empty state */
    .empty{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 16px;
      box-sizing:border-box;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.30);
    }
    .empty .card{
      max-width: 360px;
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 14px 14px;
      box-sizing:border-box;
    }
    .empty .title{ font-weight: 700; font-size: 14px; }
    .empty .sub{ margin-top: 8px; font-size: 12px; color: rgba(255,255,255,0.75); line-height: 1.35; }
    .empty .tiny{ margin-top: 10px; font-size: 11px; color: rgba(255,255,255,0.65); line-height: 1.35; }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="bg" id="bg"></div>

    <div class="preloadWrap" id="preloadWrap"><div class="preloadBar" id="preloadBar"></div></div>

    <img class="img" id="img" alt="">

    <div class="ui" id="ui">
      <div class="hud" id="hud"></div>
      <div class="dots" id="dots"></div>

      <div class="controls" id="controls">
        <button class="btn" id="btnPrev" title="Previous" aria-label="Previous">
          <svg class="icon" viewBox="0 0 24 24" fill="none">
            <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button class="btn" id="btnPlay" title="Pause" aria-label="Pause">
          <svg class="icon" id="iconPause" viewBox="0 0 24 24" fill="none">
            <path d="M9 7v10M15 7v10" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
          </svg>
          <svg class="icon" id="iconPlay" viewBox="0 0 24 24" fill="none" style="display:none;">
            <path d="M10 8l8 4-8 4V8z" fill="currentColor"/>
          </svg>
        </button>
        <button class="btn" id="btnNext" title="Next" aria-label="Next">
          <svg class="icon" viewBox="0 0 24 24" fill="none">
            <path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

<script>
(function(){
  const qs = new URLSearchParams(location.search);

  const api = qs.get('api') || '';
  const bot = qs.get('bot') || 'winston';
  const date = qs.get('date') || '';
  const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';

  const intervalMs = clampInt(qs.get('interval_ms'), 2200, 500, 60000);
  const fadeMs = clampInt(qs.get('fade_ms'), 900, 150, 8000);
  const preloadN = clampInt(qs.get('preload'), 2, 0, 24);
  const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
  const shuffle = (qs.get('shuffle') || '0') === '1' || (qs.get('shuffle') || '').toLowerCase() === 'true';

  const stage = document.getElementById('stage');
  const bg = document.getElementById('bg');
  const img = document.getElementById('img');

  const preloadWrap = document.getElementById('preloadWrap');
  const preloadBar = document.getElementById('preloadBar');

  const hud = document.getElementById('hud');
  const dots = document.getElementById('dots');

  const btnPrev = document.getElementById('btnPrev');
  const btnPlay = document.getElementById('btnPlay');
  const btnNext = document.getElementById('btnNext');
  const iconPause = document.getElementById('iconPause');
  const iconPlay = document.getElementById('iconPlay');

  img.style.objectFit = fit;
  img.style.transitionDuration = fadeMs + 'ms';

  function clampInt(v, def, min, max){
    const n = Number(v);
    if (!isFinite(n)) return def;
    return Math.max(min, Math.min(max, Math.round(n)));
  }

  function escapeHtml(s){
    return String(s||'')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }

  function renderEmpty(title, sub, tiny){
    stage.innerHTML = `
      <div class="empty">
        <div class="card">
          <div class="title">${escapeHtml(title)}</div>
          <div class="sub">${escapeHtml(sub || '')}</div>
          ${tiny ? `<div class="tiny">${tiny}</div>` : ``}
        </div>
      </div>`;
  }

  function showUi(on){
    hud.classList.toggle('show', !!on);
    dots.classList.toggle('show', !!on && photos.length > 1);
  }

  function showHud(text, mode){
    // mode: "playing" (short) or "paused" (long)
    hud.textContent = text;
    showUi(true);
    const ttl = (mode === 'paused') ? 3500 : 1300;
    clearTimeout(showHud._t);
    showHud._t = setTimeout(() => showUi(false), ttl);
  }

  function setProgress(p){
    const pct = Math.max(0, Math.min(100, Math.round(p * 100)));
    preloadBar.style.width = pct + '%';
  }
  function setPreloadVisible(on){
    preloadWrap.classList.toggle('on', !!on);
  }

  function buildApiUrl(){
    if (!api) return '';
    const u = new URL(api);
    u.searchParams.set('bot', bot);
    if (date) u.searchParams.set('date', date);
    u.searchParams.set('format', 'json');
    if (cacheS > 0) u.searchParams.set('cache_s', String(cacheS));
    if (cacheS === 0) u.searchParams.set('_t', String(Date.now()));
    return u.toString();
  }

  function preloadOne(url){
    return new Promise((resolve) => {
      const im = new Image();
      im.decoding = 'async';
      im.onload = () => resolve(true);
      im.onerror = () => resolve(false);
      im.src = url;
    });
  }

  // Shuffle without repeats until cycle completes
  function makeCycleOrder(n){
    const arr = Array.from({length:n}, (_,i)=>i);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  let photos = [];
  let idx = 0;

  let order = [];
  let orderPos = 0;

  let playing = true;
  let timer = null;

  function setPlayIcon(){
    if (playing){
      iconPause.style.display = '';
      iconPlay.style.display = 'none';
    } else {
      iconPause.style.display = 'none';
      iconPlay.style.display = '';
    }
  }

  function setControlsDisabled(){
    const one = photos.length <= 1;
    btnPrev.disabled = one;
    btnNext.disabled = one;
  }

  function ensureDotsBuilt(){
    dots.innerHTML = '';
    if (photos.length <= 1) return;
    for (let i=0;i<photos.length;i++){
      const d = document.createElement('div');
      d.className = 'dot';
      dots.appendChild(d);
    }
  }

  function updateDots(activeIndex){
    if (photos.length <= 1) return;
    const kids = dots.children;
    for (let i=0;i<kids.length;i++){
      kids[i].classList.toggle('on', i === activeIndex);
    }
  }

  function setBg(url){
    bg.style.backgroundImage = `url("${url}")`;
  }

  // ORIGINAL-style fade logic:
  // - fade out current (opacity -> 0)
  // - when hidden, swap src
  // - fade back in
  function fadeTo(url, nextIdx){
    if (!url) return;

    const doSwap = () => {
      img.removeEventListener('transitionend', doSwap);
      img.src = url;
      img.alt = 'photo ' + (nextIdx + 1);
      setBg(url);

      // fade in on next frame
      requestAnimationFrame(() => img.classList.add('show'));
    };

    // if first time (not showing yet), just show immediately after load below
    if (!img.classList.contains('show')){
      img.src = url;
      img.alt = 'photo ' + (nextIdx + 1);
      setBg(url);
      requestAnimationFrame(() => img.classList.add('show'));
      updateDots(nextIdx);
      return;
    }

    // fade out, then swap at end of transition
    img.addEventListener('transitionend', doSwap, { once: true });
    img.classList.remove('show');
    updateDots(nextIdx);
  }

  function nextIndex(){
    if (photos.length <= 1) return 0;

    if (shuffle){
      if (!order.length || orderPos >= order.length){
        order = makeCycleOrder(photos.length);
        if (order.length > 1 && order[0] === idx){
          [order[0], order[1]] = [order[1], order[0]];
        }
        orderPos = 0;
      }
      return order[orderPos++];
    }

    return (idx + 1) % photos.length;
  }

  function prevIndex(){
    if (photos.length <= 1) return 0;
    if (!shuffle) return (idx - 1 + photos.length) % photos.length;

    // simple shuffle prev: go back one in history
    if (!prevIndex._hist) prevIndex._hist = [idx];
    const h = prevIndex._hist;
    if (h.length >= 2){
      h.pop();
      return h[h.length - 1];
    }
    return idx;
  }

  function rememberHistory(i){
    if (!shuffle) return;
    if (!prevIndex._hist) prevIndex._hist = [];
    const h = prevIndex._hist;
    if (!h.length || h[h.length - 1] !== i) h.push(i);
    if (h.length > 200) h.splice(0, h.length - 200);
  }

  function stepTo(i, reason){
    if (!photos[i]) return;
    idx = i;
    rememberHistory(i);

    fadeTo(photos[i], i);

    if (reason === 'init'){
      showHud(`${date || ''} • ${bot} • ${photos.length} photos`, 'playing');
    } else if (reason === 'user'){
      showHud(`${idx + 1} / ${photos.length}`, playing ? 'playing' : 'paused');
    }
  }

  function startTimer(){
    stopTimer();
    if (!playing) return;
    if (photos.length <= 1) return;
    timer = setInterval(() => {
      const ni = nextIndex();
      stepTo(ni, 'auto');
    }, intervalMs);
  }

  function stopTimer(){
    if (timer){ clearInterval(timer); timer = null; }
  }

  // Controls
  btnNext.addEventListener('click', () => {
    if (photos.length <= 1) return;
    const ni = nextIndex();
    stepTo(ni, 'user');
    startTimer();
  });

  btnPrev.addEventListener('click', () => {
    if (photos.length <= 1) return;
    const pi = prevIndex();
    stepTo(pi, 'user');
    startTimer();
  });

  btnPlay.addEventListener('click', () => {
    playing = !playing;
    setPlayIcon();
    if (playing){
      showHud(`${idx + 1} / ${photos.length}`, 'playing');
      startTimer();
    } else {
      stopTimer();
      showHud(`${idx + 1} / ${photos.length}`, 'paused');
    }
  });

  // Background preload (non-blocking)
  async function backgroundPreload(startFrom, showBar){
    const n = photos.length;
    if (n <= 1) return;

    const indices = [];
    for (let i = 0; i < n; i++){
      if (i === startFrom) continue;
      indices.push(i);
    }

    // If preloadN is set, prioritize next N after current
    if (preloadN > 0){
      const pri = [];
      for (let k = 1; k <= preloadN; k++){
        const j = (startFrom + k) % n;
        if (j !== startFrom) pri.push(j);
      }
      // merge unique in front
      const set = new Set([startFrom]);
      const merged = [];
      for (const j of pri){ if (!set.has(j)){ set.add(j); merged.push(j); } }
      for (const j of indices){ if (!set.has(j)){ set.add(j); merged.push(j); } }
      indices.length = 0;
      indices.push(...merged);
    }

    if (showBar){
      setPreloadVisible(true);
      setProgress(0);
    }

    let done = 0;
    const total = indices.length;

    // Yield between loads to keep UI responsive
    for (const k of indices){
      await preloadOne(photos[k]);
      done++;
      if (showBar && total > 0) setProgress(done / total);
      await new Promise(r => setTimeout(r, 0));
    }

    if (showBar){
      setTimeout(() => setPreloadVisible(false), 450);
    }
  }

  // Init
  (async function init(){
    if (!api){
      renderEmpty('Missing api', 'Pass api=your api_photo_reel url in the query string.', '');
      return;
    }

    const url = buildApiUrl();
    let json = null;

    try{
      const res = await fetch(url, { cache: 'no-store' });
      json = await res.json();
    }catch(e){
      renderEmpty('Could not load', 'API fetch failed', 'Check that api_photo_reel returns JSON and is publicly accessible.');
      return;
    }

    if (!json || !json.ok){
      renderEmpty('No photos', `${date || ''} • ${bot}`, (json && json.error) ? String(json.error) : 'API returned an error.');
      return;
    }

    photos = Array.isArray(json.photos) ? json.photos.filter(Boolean) : [];
    if (!photos.length){
      renderEmpty('No photos', `${json.dateKey || date || ''} • ${bot}`, '');
      return;
    }

    // Build dots + controls now
    ensureDotsBuilt();
    updateDots(0);
    setControlsDisabled();

    // Prepare shuffle cycle
    if (shuffle){
      order = makeCycleOrder(photos.length);
      if (order.length > 1 && order[0] === 0){
        [order[0], order[1]] = [order[1], order[0]];
      }
      orderPos = 0;
      prevIndex._hist = [0];
    }

    // Show FIRST PHOTO ASAP:
    // Load first photo, show immediately once it loads (no waiting on others).
    setPreloadVisible(false);
    img.classList.remove('show');
    img.src = photos[0];
    img.alt = 'photo 1';
    setBg(photos[0]);

    img.onload = () => {
      requestAnimationFrame(() => img.classList.add('show'));
      playing = true;
      setPlayIcon();
      stepTo(0, 'init');
      startTimer();

      // After first is visible, preload remaining in background.
      // Show progress bar only if preloadN > 0 (your “tiny, classy” preference).
      backgroundPreload(0, preloadN > 0);
    };

    img.onerror = () => {
      // If first fails, try to find first loadable quickly
      (async () => {
        for (let i=1;i<photos.length;i++){
          const ok = await preloadOne(photos[i]);
          if (ok){
            img.src = photos[i];
            img.alt = 'photo ' + (i + 1);
            setBg(photos[i]);
            idx = i;
            updateDots(i);
            requestAnimationFrame(() => img.classList.add('show'));
            playing = true;
            setPlayIcon();
            showHud(`${date || ''} • ${bot} • ${photos.length} photos`, 'playing');
            startTimer();
            backgroundPreload(i, preloadN > 0);
            return;
          }
        }
        renderEmpty('No photos', `${json.dateKey || date || ''} • ${bot}`, 'All images failed to load.');
      })();
    };

  })();

})();
</script>
</body>
</html>

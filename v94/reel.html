<!--
reel.html
LifeLog Photo Reel (GitHub Pages)

Updates in this version:
  ✅ Non-repeating shuffle (no repeats until all shown)
  ✅ Controls: smaller, responsive sizing for skybox iframes
  ✅ Controls: fade sooner while playing, longer when paused
  ✅ Buttons wired reliably (stopPropagation + pointer events)
  ✅ Disable Prev/Next when only 1 photo
  ✅ Classy preload progress bar + graceful "no photos" state
  ✅ Subtle crossfade easing
  ✅ Background blur layer (helps portrait shots feel framed)

Expected URL params (examples):
  reel.html?api=<ENCODED_API_URL>&bot=winston&date=2025-12-20&fit=contain&w=1200&preload=2&cache_s=600&interval_ms=2200&fade_ms=450&shuffle=1

Notes:
- Keyboard support intentionally NOT included (per your request).
- The api should return JSON like: { ok:true, dateKey:"YYYY-MM-DD", photos:["https://...","https://..."] }
  (or JSONP if you implemented that; this file uses JSON fetch by default).
-->

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --bg: #0b0f16;
      --glass: rgba(255,255,255,0.06);
      --glass2: rgba(255,255,255,0.10);
      --ring: rgba(255,255,255,0.18);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);

      --radius: 14px;
      --hudPad: 12px;

      --ctrlBg: rgba(0,0,0,0.38);
      --ctrlRing: rgba(255,255,255,0.22);

      --barBg: rgba(255,255,255,0.14);
      --barFg: rgba(255,255,255,0.72);
    }

    html, body { height:100%; margin:0; background: transparent; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    .frame{
      position:relative;
      width:100%;
      height:100%;
      border-radius: var(--radius);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(0,0,0,0.20), rgba(0,0,0,0.35));
    }

    /* Background blur layer (helps portrait shots look framed) */
    .bg{
      position:absolute;
      inset:0;
      background: #111;
      background-size: cover;
      background-position: center;
      filter: blur(24px) saturate(1.05);
      transform: scale(1.12);
      opacity: 0;
      transition: opacity 420ms ease;
    }
    .bg.on{ opacity: 1; }

    .vignette{
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.10), rgba(0,0,0,0.55));
      pointer-events:none;
    }

    /* Main image */
    .img{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      opacity:0;
      transition: opacity var(--fadeMs, 450ms) cubic-bezier(.22,.61,.36,1);
      will-change: opacity;
      object-fit: var(--fit, contain);
    }
    .img.on{ opacity: 1; }

    /* Top-left tiny label */
    .tag{
      position:absolute;
      top: var(--hudPad);
      left: var(--hudPad);
      z-index: 8;
      font-size: 12px;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.40);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: calc(100% - 2*var(--hudPad));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;
    }

    /* Preload progress */
    .progress{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      width: min(220px, 62vw);
      z-index: 9;
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events:none;
    }
    .progress.on{ opacity: 1; }
    .progress .label{
      font-size: 12px;
      color: var(--muted);
      text-align:center;
      margin-bottom: 8px;
      letter-spacing: 0.2px;
    }
    .progress .bar{
      height: 6px;
      border-radius: 999px;
      background: var(--barBg);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .progress .fill{
      height: 100%;
      width: 0%;
      background: var(--barFg);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    /* Empty / no photos state */
    .empty{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
      box-sizing:border-box;
      color: var(--text);
      z-index: 10;
      background: linear-gradient(180deg, rgba(0,0,0,0.30), rgba(0,0,0,0.50));
    }
    .empty .card{
      width: min(320px, 80vw);
      border-radius: 16px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(12px);
      padding: 16px 14px;
    }
    .empty .title{
      font-weight: 800;
      font-size: 14px;
      margin-bottom: 6px;
      letter-spacing: 0.2px;
    }
    .empty .sub{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* Controls */
    .controls{
      position:absolute;
      left:50%;
      bottom: calc(var(--hudPad) + 14px);
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: clamp(8px, 2.2vw, 14px);
      padding: clamp(6px, 1.6vw, 10px);
      border-radius: 999px;
      background: var(--ctrlBg);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      z-index: 8;

      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    .controls.on{
      opacity: 1;
      pointer-events: auto;
    }

    .btn{
      width: clamp(26px, 6vw, 38px);
      height: clamp(26px, 6vw, 38px);
      border-radius: 999px;
      border: 1px solid var(--ctrlRing);
      background: rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: scale(0.96); }

    .btn svg{
      width: clamp(12px, 3.2vw, 18px);
      height: clamp(12px, 3.2vw, 18px);
      fill: none;
      stroke: rgba(255,255,255,0.86);
      stroke-width: 2.2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .btn.main{
      width: clamp(30px, 7vw, 42px);
      height: clamp(30px, 7vw, 42px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.26);
    }
    .btn.main svg{
      width: clamp(14px, 3.6vw, 20px);
      height: clamp(14px, 3.6vw, 20px);
    }

    .btn.disabled{
      opacity: 0.35;
      cursor: default;
      pointer-events: none;
    }

    /* Click-anywhere surface to show controls */
    .hotzone{
      position:absolute;
      inset:0;
      z-index: 6;
      background: transparent;
    }
  </style>
</head>

<body>
  <div class="frame" id="frame">
    <div class="bg" id="bg"></div>
    <div class="vignette"></div>
    <div class="hotzone" id="hotzone"></div>

    <div class="tag" id="tag" style="display:none;"></div>

    <div class="progress" id="progress" style="display:none;">
      <div class="label" id="progressLabel">loading photos…</div>
      <div class="bar"><div class="fill" id="progressFill"></div></div>
    </div>

    <div class="controls" id="controls" aria-label="controls">
      <div class="btn" id="btnPrev" title="Previous" aria-label="Previous">
        <!-- left chevron -->
        <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
      </div>

      <div class="btn main" id="btnPlay" title="Play/Pause" aria-label="Play/Pause">
        <!-- play icon (default), swapped to pause in JS -->
        <svg id="iconPlay" viewBox="0 0 24 24"><path d="M9 8l10 4-10 4z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" style="display:none;">
          <path d="M8 6v12"/><path d="M16 6v12"/>
        </svg>
      </div>

      <div class="btn" id="btnNext" title="Next" aria-label="Next">
        <!-- right chevron -->
        <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Params
    // -----------------------------
    const qs = new URLSearchParams(location.search);

    // Your API endpoint can be passed as api=... or you can hardcode it below.
    // Example:
    // api=https%3A%2F%2Fscript.google.com%2Fmacros%2Fs%2F...%2Fexec%3Fr%3Dapi_photo_reel
    const apiBase = qs.get('api') || ''; // optional; recommended to pass full URL including r=api_photo_reel
    const bot = qs.get('bot') || 'winston';
    const date = qs.get('date') || '';  // YYYY-MM-DD; if blank, API may default server-side

    const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';
    const fadeMs = clampInt(qs.get('fade_ms'), 450, 150, 2500);
    const intervalMs = clampInt(qs.get('interval_ms'), 2200, 700, 20000);
    const preloadN = clampInt(qs.get('preload'), 2, 0, 12);
    const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
    const shuffle = (qs.get('shuffle') || '1') !== '0'; // default on
    const wParam = qs.get('w'); // optional (you may use this in your API to pick thumbs)

    // Controls auto-hide timing:
    const HIDE_MS_PLAYING = 1200; // fade sooner while playing
    const HIDE_MS_PAUSED  = 3600; // longer when paused

    // Apply CSS variables
    document.documentElement.style.setProperty('--fit', fit);
    document.documentElement.style.setProperty('--fadeMs', fadeMs + 'ms');

    // -----------------------------
    // DOM
    // -----------------------------
    const frame = document.getElementById('frame');
    const bg = document.getElementById('bg');
    const tag = document.getElementById('tag');

    const progress = document.getElementById('progress');
    const progressLabel = document.getElementById('progressLabel');
    const progressFill = document.getElementById('progressFill');

    const controls = document.getElementById('controls');
    const hotzone = document.getElementById('hotzone');

    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnPlay = document.getElementById('btnPlay');
    const iconPlay = document.getElementById('iconPlay');
    const iconPause = document.getElementById('iconPause');

    // -----------------------------
    // State
    // -----------------------------
    let photos = [];     // original list (urls)
    let ok = [];         // verified/preloaded urls
    let imgs = [];       // <img> elements for main layer
    let started = false;

    // Non-repeating shuffle deck
    let deck = [];
    let deckPos = 0;

    let idx = 0;         // current index in ok[]
    let timer = null;
    let isPlaying = true;

    let hideT = null;

    // -----------------------------
    // Helpers
    // -----------------------------
    function clampInt(v, def, min, max){
      const n = Number(v);
      if (!Number.isFinite(n)) return def;
      return Math.max(min, Math.min(max, Math.round(n)));
    }

    function safeText(s){
      return String(s || '').replace(/[<>]/g,'');
    }

    function showEmpty(titleText, subText){
      const d = document.createElement('div');
      d.className = 'empty';
      d.innerHTML =
        '<div class="card">' +
          '<div class="title">' + safeText(titleText) + '</div>' +
          '<div class="sub">' + safeText(subText) + '</div>' +
        '</div>';
      frame.appendChild(d);
    }

    function showProgress(on, label){
      if (!on){
        progress.classList.remove('on');
        progress.style.display = 'none';
        return;
      }
      progress.style.display = '';
      if (label) progressLabel.textContent = label;
      requestAnimationFrame(() => progress.classList.add('on'));
    }

    function setProgress(pct){
      const p = Math.max(0, Math.min(100, pct));
      progressFill.style.width = p + '%';
    }

    function showControls(){
      controls.classList.add('on');
      scheduleHideControls();
    }

    function scheduleHideControls(){
      if (hideT) clearTimeout(hideT);
      const ms = isPlaying ? HIDE_MS_PLAYING : HIDE_MS_PAUSED;
      hideT = setTimeout(() => {
        controls.classList.remove('on');
      }, ms);
    }

    function syncPlayIcon(){
      if (isPlaying){
        iconPlay.style.display = 'none';
        iconPause.style.display = '';
      } else {
        iconPlay.style.display = '';
        iconPause.style.display = 'none';
      }
    }

    function disablePrevNextIfNeeded(){
      const one = (ok.length <= 1);
      if (one){
        btnPrev.classList.add('disabled');
        btnNext.classList.add('disabled');
      } else {
        btnPrev.classList.remove('disabled');
        btnNext.classList.remove('disabled');
      }
    }

    function setTag(text){
      tag.textContent = text;
      tag.style.display = '';
    }

    function buildApiUrl(){
      // If apiBase is provided as a full URL, we just add bot/date/etc.
      // If empty, we can’t fetch and will show an error.
      if (!apiBase) return '';

      // apiBase might already include query params (like ?r=api_photo_reel)
      const u = new URL(apiBase, location.href);

      if (bot) u.searchParams.set('bot', bot);
      if (date) u.searchParams.set('date', date);
      if (wParam) u.searchParams.set('w', wParam);
      if (cacheS) u.searchParams.set('cache_s', String(cacheS));

      return u.toString();
    }

    async function fetchJson(url){
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      return await resp.json();
    }

    function shuffleArray(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function resetDeck(currentIndex){
      const indices = ok.map((_, i) => i);
      // Build a new shuffled order, but try to avoid immediate repeat of current index
      let shuffled = shuffle ? shuffleArray(indices) : indices;
      if (shuffle && ok.length > 1 && shuffled[0] === currentIndex){
        // swap first with another position
        const swapWith = 1 + Math.floor(Math.random() * (shuffled.length - 1));
        [shuffled[0], shuffled[swapWith]] = [shuffled[swapWith], shuffled[0]];
      }
      deck = shuffled;
      deckPos = 0;
    }

    function nextFromDeck(){
      if (ok.length <= 1) return 0;
      if (!deck.length || deckPos >= deck.length){
        resetDeck(idx);
      }
      // Ensure deck[deckPos] is not the current index if possible
      if (ok.length > 1 && deck[deckPos] === idx){
        deckPos++;
        if (deckPos >= deck.length){
          resetDeck(idx);
        }
      }
      const ni = deck[deckPos];
      deckPos++;
      return ni;
    }

    function prevIndexSimple(){
      // For "prev" we’ll step back in the already-viewed history if possible.
      // Simple approach: go to (idx-1) wrapping (works fine with shuffle experience).
      if (ok.length <= 1) return 0;
      return (idx - 1 + ok.length) % ok.length;
    }

    function setBgFor(src){
      bg.style.backgroundImage = `url("${src}")`;
      bg.classList.add('on');
    }

    function showIndex(i){
      if (!imgs.length) return;
      const prev = idx;
      idx = i;

      imgs[prev]?.classList.remove('on');
      imgs[idx]?.classList.add('on');

      setBgFor(ok[idx]);
    }

    function stopTimer(){
      if (timer) clearInterval(timer);
      timer = null;
    }

    function startTimer(){
      stopTimer();
      if (!isPlaying) return;
      if (ok.length <= 1) return;
      timer = setInterval(() => {
        const ni = nextFromDeck();
        showIndex(ni);
      }, Math.max(300, intervalMs));
    }

    function wireControls(){
      // Hotzone toggles visibility
      hotzone.addEventListener('click', () => {
        showControls();
      });

      // Always show controls on pointer movement inside frame (nice in skybox)
      frame.addEventListener('pointermove', () => {
        showControls();
      }, { passive: true });

      btnPlay.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();

        isPlaying = !isPlaying;
        syncPlayIcon();
        startTimer();
      });

      btnNext.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();
        if (!started || ok.length <= 1) return;
        const ni = nextFromDeck();
        showIndex(ni);
      });

      btnPrev.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        showControls();
        if (!started || ok.length <= 1) return;
        const pi = prevIndexSimple();
        showIndex(pi);
      });
    }

    function preloadImage(src){
      return new Promise((resolve) => {
        const im = new Image();
        im.decoding = 'async';
        im.loading = 'eager';
        im.onload = () => resolve({ ok:true, src });
        im.onerror = () => resolve({ ok:false, src });
        im.src = src;
      });
    }

    async function primeImages(){
      // Validate and preload at least the first N (or all if small)
      const total = photos.length;
      ok = [];
      let loaded = 0;

      showProgress(true, 'loading photos…');
      setProgress(0);

      // We will attempt to load all, but show progress based on tries.
      for (let i = 0; i < total; i++){
        const r = await preloadImage(photos[i]);
        loaded++;
        setProgress(Math.round((loaded / total) * 100));
        if (r.ok) ok.push(r.src);
      }

      // If preloadN > 0 and we have a lot, we’ve already validated all.
      // If you want to cap, we can, but best UX is keeping all available for shuffle.
      showProgress(false);
    }

    function buildLayers(){
      // Build image layers
      imgs = ok.map((src, i) => {
        const im = document.createElement('img');
        im.className = 'img';
        im.alt = 'photo ' + (i + 1);
        im.decoding = 'async';
        im.loading = (i === 0) ? 'eager' : 'lazy';
        im.src = src;
        frame.appendChild(im);
        return im;
      });

      // Put controls above images
      frame.appendChild(controls);

      // Init deck
      resetDeck(0);

      // Show first
      idx = 0;
      imgs[0].classList.add('on');
      setBgFor(ok[0]);

      started = true;

      disablePrevNextIfNeeded();
      syncPlayIcon();
      showControls();
      startTimer();
    }

    async function main(){
      wireControls();

      // If no apiBase, we can still run with hardcoded state by embedding photos[] in the HTML,
      // but for your setup we expect api param.
      const apiUrl = buildApiUrl();

      if (!apiUrl){
        showEmpty('Missing api', 'Pass api=<your api_photo_reel url> in the query string.');
        return;
      }

      try{
        const data = await fetchJson(apiUrl);

        if (!data || !data.ok){
          const err = (data && data.error) ? String(data.error) : 'API returned not ok';
          showEmpty('No photos', err);
          return;
        }

        const dateKey = data.dateKey || date || '';
        const count = Array.isArray(data.photos) ? data.photos.length : 0;

        setTag((dateKey ? dateKey : 'date') + ' • ' + bot + (count ? (' • ' + count + ' photos') : ''));

        if (!count){
          showEmpty('No photos', (dateKey ? dateKey : '') + (bot ? (' • ' + bot) : ''));
          return;
        }

        // Photos from API
        photos = data.photos.slice();

        // Optional: if preload param passed, we at least show a classy progress bar while validating.
        // (This validates all so shuffle never hits a broken file.)
        await primeImages();

        if (!ok.length){
          showEmpty('No photos', 'All photos failed to load (permissions or invalid URLs).');
          return;
        }

        buildLayers();

      } catch (e){
        showEmpty('No photos', 'Failed to load: ' + String(e && e.message ? e.message : e));
      }
    }

    main();
  </script>
</body>
</html>

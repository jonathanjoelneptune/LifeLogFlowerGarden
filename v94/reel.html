<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --radius: 14px;
      --hudPad: 10px;

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.62);

      --ctrlBg: rgba(0,0,0,0.38);
      --ctrlRing: rgba(255,255,255,0.18);

      --barBg: rgba(255,255,255,0.14);
      --barFg: rgba(255,255,255,0.72);

      --dotOff: rgba(255,255,255,0.30);
      --dotOn: rgba(255,255,255,0.92);

      --fadeMs: 450ms;
      --fit: contain;

      --blur: 22px;
    }

    html, body { height:100%; margin:0; background: transparent; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    .frame{
      position:relative;
      width:100%;
      height:100%;
      border-radius: var(--radius);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.40));
    }

    /* background blur */
    .bg{
      position:absolute;
      inset:-18px;
      background: #111;
      background-size: cover;
      background-position: center;
      filter: blur(var(--blur)) saturate(1.05);
      transform: scale(1.10);
      opacity: 0;
      transition: opacity 420ms ease;
      will-change: opacity;
    }
    .bg.on{ opacity: 1; }

    .vignette{
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.10), rgba(0,0,0,0.58));
      pointer-events:none;
    }

    /* two-layer crossfade images (THIS is the “perfect” fade pattern) */
    .img{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      opacity:0;
      transition: opacity var(--fadeMs) cubic-bezier(.22,.61,.36,1);
      will-change: opacity;
      object-fit: var(--fit);
      user-select:none;
      -webkit-user-drag:none;
    }
    .img.on{ opacity:1; }

    /* optional tiny tag */
    .tag{
      position:absolute;
      top: var(--hudPad);
      left: var(--hudPad);
      z-index: 10;
      font-size: 11px;
      color: var(--text);
      padding: 5px 9px;
      border-radius: 999px;
      background: rgba(0,0,0,0.38);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      max-width: calc(100% - 2*var(--hudPad));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;

      opacity: 0;
      transform: translateY(4px);
      transition: opacity 220ms ease, transform 220ms ease;
    }
    .tag.show{ opacity: 1; transform: translateY(0); }

    /* preload progress (tiny, classy) */
    .progress{
      position:absolute;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      width: min(220px, 70vw);
      z-index: 11;
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events:none;
    }
    .progress.on{ opacity: 1; }
    .progress .bar{
      height: 4px;
      border-radius: 999px;
      background: var(--barBg);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .progress .fill{
      height: 100%;
      width: 0%;
      background: var(--barFg);
      border-radius: 999px;
      transition: width 160ms ease;
    }

    /* graceful empty state */
    .empty{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
      box-sizing:border-box;
      color: var(--text);
      z-index: 12;
      background: linear-gradient(180deg, rgba(0,0,0,0.26), rgba(0,0,0,0.52));
    }
    .empty .card{
      width: min(340px, 84vw);
      border-radius: 16px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(12px);
      padding: 16px 14px;
    }
    .empty .title{
      font-weight: 800;
      font-size: 14px;
      margin-bottom: 6px;
      letter-spacing: 0.2px;
    }
    .empty .sub{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* controls + dots (fade together) */
    .ui{
      position:absolute;
      left:50%;
      bottom: calc(var(--hudPad) + 10px);
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: clamp(8px, 2.2vw, 14px);
      padding: clamp(6px, 1.6vw, 10px);
      border-radius: 999px;
      background: var(--ctrlBg);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      z-index: 10;

      opacity: 0;
      transform: translateX(-50%) translateY(6px);
      transition: opacity 220ms ease, transform 220ms ease;
      pointer-events: none;
    }
    .ui.on{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    .dots{
      display:flex;
      align-items:center;
      gap: 6px;
      margin: 0 4px;
      opacity: 0.92;
    }
    .dot{
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--dotOff);
      transition: background 160ms ease, transform 160ms ease, opacity 160ms ease;
    }
    .dot.on{
      background: var(--dotOn);
      transform: scale(1.05);
    }

    .btn{
      width: clamp(24px, 5.6vw, 36px);
      height: clamp(24px, 5.6vw, 36px);
      border-radius: 999px;
      border: 1px solid var(--ctrlRing);
      background: rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: scale(0.96); }

    .btn svg{
      width: clamp(12px, 3.1vw, 18px);
      height: clamp(12px, 3.1vw, 18px);
      fill: none;
      stroke: rgba(255,255,255,0.86);
      stroke-width: 2.2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .btn.main{
      width: clamp(28px, 6.5vw, 40px);
      height: clamp(28px, 6.5vw, 40px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.24);
    }

    .btn.disabled{
      opacity: 0.35;
      cursor: default;
      pointer-events: none;
    }

    /* hover/move shows UI */
    .hotzone{
      position:absolute;
      inset:0;
      z-index: 9;
      background: transparent;
    }
  </style>
</head>

<body>
  <div class="frame" id="frame">
    <div class="bg" id="bg"></div>
    <div class="vignette"></div>

    <img class="img" id="imgA" alt="">
    <img class="img" id="imgB" alt="">

    <div class="hotzone" id="hotzone"></div>

    <div class="tag" id="tag" style="display:none;"></div>

    <div class="progress" id="progress" style="display:none;">
      <div class="bar"><div class="fill" id="progressFill"></div></div>
    </div>

    <div class="ui" id="ui" aria-label="controls">
      <button class="btn" id="btnPrev" title="Previous" aria-label="Previous">
        <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
      </button>

      <div class="dots" id="dots" aria-label="dots"></div>

      <button class="btn main" id="btnPlay" title="Play/Pause" aria-label="Play/Pause">
        <svg id="iconPlay" viewBox="0 0 24 24"><path d="M9 8l10 4-10 4z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" style="display:none;"><path d="M8 6v12"/><path d="M16 6v12"/></svg>
      </button>

      <button class="btn" id="btnNext" title="Next" aria-label="Next">
        <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg>
      </button>
    </div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const apiBase = qs.get('api') || '';
  const bot = qs.get('bot') || 'winston';
  const date = qs.get('date') || '';

  const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';
  const fadeMs = clampInt(qs.get('fade_ms'), 450, 150, 2500);
  const intervalMs = clampInt(qs.get('interval_ms'), 2200, 700, 20000);
  const preloadN = clampInt(qs.get('preload'), 2, 0, 24);         // how many “next” to prioritize
  const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
  const shuffle = (qs.get('shuffle') || '1') !== '0';
  const showTag = (qs.get('tag') || '0') !== '0';                  // default OFF (prevents “HUD reload” vibe)
  const showDots = (qs.get('dots') || '1') !== '0';                // default ON

  const HIDE_MS_PLAYING = 1100;
  const HIDE_MS_PAUSED  = 3200;

  document.documentElement.style.setProperty('--fit', fit);
  document.documentElement.style.setProperty('--fadeMs', fadeMs + 'ms');

  const frame = document.getElementById('frame');
  const bg = document.getElementById('bg');
  const tagEl = document.getElementById('tag');

  const progress = document.getElementById('progress');
  const progressFill = document.getElementById('progressFill');

  const hotzone = document.getElementById('hotzone');
  const ui = document.getElementById('ui');

  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnPlay = document.getElementById('btnPlay');
  const iconPlay = document.getElementById('iconPlay');
  const iconPause = document.getElementById('iconPause');

  const dotsEl = document.getElementById('dots');

  const imgA = document.getElementById('imgA');
  const imgB = document.getElementById('imgB');

  let photos = [];
  let ok = [];

  // active layer toggle
  let frontIsA = true;
  let frontImg = imgA;
  let backImg = imgB;

  let idx = 0;
  let isPlaying = true;
  let timer = null;
  let hideT = null;

  // non-repeating shuffle deck
  let deck = [];
  let deckPos = 0;

  function clampInt(v, def, min, max){
    const n = Number(v);
    if (!Number.isFinite(n)) return def;
    return Math.max(min, Math.min(max, Math.round(n)));
  }

  function safeText(s){
    return String(s || '').replace(/[<>]/g,'');
  }

  function showEmpty(titleText, subText){
    const d = document.createElement('div');
    d.className = 'empty';
    d.innerHTML =
      '<div class="card">' +
        '<div class="title">' + safeText(titleText) + '</div>' +
        '<div class="sub">' + safeText(subText) + '</div>' +
      '</div>';
    frame.appendChild(d);
  }

  function setBgFor(src){
    bg.style.backgroundImage = `url("${src}")`;
    bg.classList.add('on');
  }

  function showProgress(on){
    if (!on){
      progress.classList.remove('on');
      progress.style.display = 'none';
      return;
    }
    progress.style.display = '';
    requestAnimationFrame(() => progress.classList.add('on'));
  }

  function setProgress(pct){
    const p = Math.max(0, Math.min(100, pct));
    progressFill.style.width = p + '%';
  }

  function showUI(){
    ui.classList.add('on');
    scheduleHideUI();
  }

  function scheduleHideUI(){
    if (hideT) clearTimeout(hideT);
    const ms = isPlaying ? HIDE_MS_PLAYING : HIDE_MS_PAUSED;
    hideT = setTimeout(() => ui.classList.remove('on'), ms);
  }

  function syncPlayIcon(){
    if (isPlaying){
      iconPlay.style.display = 'none';
      iconPause.style.display = '';
    } else {
      iconPlay.style.display = '';
      iconPause.style.display = 'none';
    }
  }

  function disablePrevNextIfNeeded(){
    const one = (ok.length <= 1);
    btnPrev.classList.toggle('disabled', one);
    btnNext.classList.toggle('disabled', one);
  }

  function buildApiUrl(){
    if (!apiBase) return '';
    const u = new URL(apiBase, location.href);
    if (bot) u.searchParams.set('bot', bot);
    if (date) u.searchParams.set('date', date);
    if (cacheS > 0) u.searchParams.set('cache_s', String(cacheS));
    if (cacheS === 0) u.searchParams.set('_t', String(Date.now()));
    return u.toString();
  }

  async function fetchJson(url){
    const resp = await fetch(url, { cache: 'no-store' });
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    return await resp.json();
  }

  function shuffleArray(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function resetDeck(currentIndex){
    const indices = ok.map((_, i) => i);
    let shuffled = shuffle ? shuffleArray(indices) : indices;
    if (shuffle && ok.length > 1 && shuffled[0] === currentIndex){
      const swapWith = 1 + Math.floor(Math.random() * (shuffled.length - 1));
      [shuffled[0], shuffled[swapWith]] = [shuffled[swapWith], shuffled[0]];
    }
    deck = shuffled;
    deckPos = 0;
  }

  function nextFromDeck(){
    if (ok.length <= 1) return 0;
    if (!deck.length || deckPos >= deck.length) resetDeck(idx);

    if (ok.length > 1 && deck[deckPos] === idx){
      deckPos++;
      if (deckPos >= deck.length) resetDeck(idx);
    }
    const ni = deck[deckPos];
    deckPos++;
    return ni;
  }

  function prevSimple(){
    if (ok.length <= 1) return 0;
    return (idx - 1 + ok.length) % ok.length;
  }

  function buildDots(){
    dotsEl.innerHTML = '';
    if (!showDots || ok.length <= 1){
      dotsEl.style.display = 'none';
      return;
    }
    dotsEl.style.display = 'flex';
    for (let i = 0; i < ok.length; i++){
      const d = document.createElement('div');
      d.className = 'dot' + (i === 0 ? ' on' : '');
      dotsEl.appendChild(d);
    }
  }

  function setDot(i){
    if (!showDots || ok.length <= 1) return;
    const kids = dotsEl.children;
    for (let k = 0; k < kids.length; k++){
      kids[k].classList.toggle('on', k === i);
    }
  }

  function swapFrontBack(){
    frontIsA = !frontIsA;
    frontImg = frontIsA ? imgA : imgB;
    backImg = frontIsA ? imgB : imgA;
  }

  function preloadImage(src){
    return new Promise((resolve) => {
      const im = new Image();
      im.decoding = 'async';
      im.onload = () => resolve(true);
      im.onerror = () => resolve(false);
      im.src = src;
    });
  }

  async function ensureLoaded(src){
    // Decode/load gate to avoid jarring fade into blank
    const okLoad = await preloadImage(src);
    return okLoad;
  }

  async function showIndex(i){
    if (!ok[i]) return;
    if (i === idx && frontImg.classList.contains('on')) return;

    const nextSrc = ok[i];

    // Load next into back layer first (hidden)
    backImg.classList.remove('on');
    backImg.src = nextSrc;

    const loaded = await ensureLoaded(nextSrc);
    if (!loaded){
      // if a particular url fails, skip forward once
      if (ok.length > 1){
        const ni = nextFromDeck();
        return showIndex(ni);
      }
      return;
    }

    // Set background blur to the same image
    setBgFor(nextSrc);

    // Crossfade: back in, front out (no UI changes here)
    backImg.classList.add('on');
    frontImg.classList.remove('on');

    // Now back becomes front for next time
    swapFrontBack();

    idx = i;
    setDot(idx);
  }

  function stopTimer(){
    if (timer) clearInterval(timer);
    timer = null;
  }

  function startTimer(){
    stopTimer();
    if (!isPlaying) return;
    if (ok.length <= 1) return;
    timer = setInterval(() => {
      const ni = nextFromDeck();
      showIndex(ni);
    }, Math.max(300, intervalMs));
  }

  function wireControls(){
    hotzone.addEventListener('pointermove', () => showUI(), { passive: true });
    hotzone.addEventListener('mouseenter', () => showUI(), { passive: true });

    btnPlay.addEventListener('click', (ev) => {
      ev.preventDefault(); ev.stopPropagation();
      showUI();
      isPlaying = !isPlaying;
      syncPlayIcon();
      if (isPlaying) startTimer(); else stopTimer();
    });

    btnNext.addEventListener('click', (ev) => {
      ev.preventDefault(); ev.stopPropagation();
      showUI();
      if (ok.length <= 1) return;
      const ni = nextFromDeck();
      showIndex(ni);
      if (isPlaying) startTimer();
    });

    btnPrev.addEventListener('click', (ev) => {
      ev.preventDefault(); ev.stopPropagation();
      showUI();
      if (ok.length <= 1) return;
      const pi = prevSimple();
      showIndex(pi);
      if (isPlaying) startTimer();
    });
  }

  async function backgroundPreload(){
    // Non-blocking preload/validation. Does NOT delay first image.
    if (ok.length <= 1) return;

    showProgress(true);
    setProgress(0);

    const n = ok.length;
    const indices = [];
    for (let i = 0; i < n; i++){
      if (i === idx) continue;
      indices.push(i);
    }

    // prioritize next preloadN after current idx
    if (preloadN > 0 && n > 2){
      const pri = [];
      for (let k = 1; k <= preloadN; k++){
        pri.push((idx + k) % n);
      }
      const set = new Set([idx]);
      const merged = [];
      for (const j of pri){ if (!set.has(j)){ set.add(j); merged.push(j); } }
      for (const j of indices){ if (!set.has(j)){ set.add(j); merged.push(j); } }
      indices.length = 0;
      indices.push(...merged);
    }

    let done = 0;
    const total = indices.length;

    for (const j of indices){
      await preloadImage(ok[j]);
      done++;
      setProgress(total ? Math.round((done / total) * 100) : 100);
      await new Promise(r => setTimeout(r, 0)); // yield
    }

    setTimeout(() => showProgress(false), 450);
  }

  async function main(){
    wireControls();

    const apiUrl = buildApiUrl();
    if (!apiUrl){
      showEmpty('Missing api', 'Pass api=<your api_photo_reel url> in the query string.');
      return;
    }

    let data;
    try{
      data = await fetchJson(apiUrl);
    } catch (e){
      showEmpty('No photos', 'Failed to load: ' + String(e && e.message ? e.message : e));
      return;
    }

    if (!data || !data.ok){
      const err = (data && data.error) ? String(data.error) : 'API returned not ok';
      showEmpty('No photos', err);
      return;
    }

    photos = Array.isArray(data.photos) ? data.photos.filter(Boolean) : [];
    if (!photos.length){
      showEmpty('No photos', (data.dateKey || date || '') + ' • ' + bot);
      return;
    }

    // Keep the tag STATIC (no re-setting per photo, prevents “reloading UI” feel)
    if (showTag){
      const dateKey = data.dateKey || date || '';
      const count = photos.length;
      tagEl.textContent = (dateKey ? dateKey : 'date') + ' • ' + bot + (count ? (' • ' + count + ' photos') : '');
      tagEl.style.display = '';
      requestAnimationFrame(() => tagEl.classList.add('show'));
    } else {
      tagEl.style.display = 'none';
    }

    // Use all photos as playable list (don’t block on validating all)
    ok = photos.slice();

    // Build dots once
    buildDots();

    // Init shuffle deck
    resetDeck(0);

    // Show first photo ASAP (only wait on first image load)
    const first = ok[0];
    backImg.src = first;
    const loaded = await ensureLoaded(first);
    if (!loaded){
      showEmpty('No photos', 'First photo failed to load.');
      return;
    }

    // Put first image on front
    frontImg.src = first;
    frontImg.classList.add('on');
    backImg.classList.remove('on');
    setBgFor(first);

    idx = 0;
    setDot(0);

    disablePrevNextIfNeeded();
    syncPlayIcon();
    showUI();
    startTimer();

    // Start background preload without affecting playback
    backgroundPreload();
  }

  main();
})();
</script>
</body>
</html>

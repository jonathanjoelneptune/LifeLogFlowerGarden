<!--
reel.html
LifeLog Photo Reel (GitHub Pages)

Behavior (current):
  ✅ Loads photos from your Apps Script API: r=api_photo_reel
  ✅ Shows FIRST image as soon as it loads (no waiting for all)
  ✅ Continues preloading in the background while slideshow can run
  ✅ Non-repeating shuffle (no repeats until all shown)
  ✅ Background blur layer (portrait shots look framed)
  ✅ Smooth, non-jarring crossfade (two-layer crossfade)
  ✅ Graceful "no photos" art state
  ✅ Tiny classy preload bar (only while first image is loading / initial preloads)
  ✅ Controls only appear on hover/move (DEFAULT: UI hidden)
  ✅ Dots optional, Tag optional (DEFAULT: hidden)

URL params (example):
  reel.html?
    api=<ENCODED_API_URL_WITH_r=api_photo_reel>
    &bot=winston
    &date=2025-12-20
    &fit=contain            (contain|cover)
    &w=1200                 (optional pass-through to API)
    &cache_s=600            (optional pass-through to API)
    &preload=2              (# of images to preload ASAP after first)
    &interval_ms=2200
    &fade_ms=450
    &shuffle=1              (1=on, 0=off)
    &tag=0                  (0=hide, 1=show)
    &dots=0                 (0=hide, 1=show)

Notes:
- Keyboard support intentionally NOT included.
- Prev/Next disabled if only 1 image.
-->

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --radius: 14px;
      --pad: 10px;

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);

      --ctrlBg: rgba(0,0,0,0.34);
      --ctrlRing: rgba(255,255,255,0.18);

      --barBg: rgba(255,255,255,0.14);
      --barFg: rgba(255,255,255,0.70);

      --fadeMs: 450ms;
      --fit: contain;
    }

    html, body { height:100%; margin:0; background: transparent; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    .frame{
      position:relative;
      width:100%;
      height:100%;
      border-radius: var(--radius);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.36));
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }

    /* Background blur layer */
    .bg{
      position:absolute;
      inset:0;
      background: #0b0f16;
      background-size: cover;
      background-position: center;
      filter: blur(22px) saturate(1.05);
      transform: scale(1.12);
      opacity: 0;
      transition: opacity 420ms ease;
    }
    .bg.on{ opacity: 1; }

    .vignette{
      position:absolute;
      inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.08), rgba(0,0,0,0.55));
      pointer-events:none;
    }

    /* Two-layer crossfade (prevents jarring swaps) */
    .imgLayer{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: var(--fit);
      opacity: 0;
      transition: opacity var(--fadeMs) cubic-bezier(.22,.61,.36,1);
      will-change: opacity;
      background: transparent;
    }
    .imgLayer.on{ opacity: 1; }

    /* Top-left tag (optional, default hidden via JS) */
    .tag{
      position:absolute;
      top: var(--pad);
      left: var(--pad);
      z-index: 9;
      font-size: 11px;
      color: var(--text);
      padding: 5px 9px;
      border-radius: 999px;
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      max-width: calc(100% - 2*var(--pad));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;

      opacity: 0;
      transition: opacity 220ms ease;
    }
    .tag.on{ opacity: 1; }

    /* Dots (optional, default hidden via JS) */
    .dots{
      position:absolute;
      left:50%;
      bottom: calc(var(--pad) + 44px);
      transform: translateX(-50%);
      z-index: 9;
      display:flex;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.20);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);

      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events:none;
    }
    .dots.on{ opacity: 1; }
    .dot{
      width: 5px; height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,0.28);
    }
    .dot.on{ background: rgba(255,255,255,0.82); }

    /* Preload progress (tiny, classy) */
    .progress{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      width: min(220px, 62vw);
      z-index: 10;
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events:none;
    }
    .progress.on{ opacity: 1; }
    .progress .label{
      font-size: 12px;
      color: var(--muted);
      text-align:center;
      margin-bottom: 8px;
      letter-spacing: 0.2px;
    }
    .progress .bar{
      height: 6px;
      border-radius: 999px;
      background: var(--barBg);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .progress .fill{
      height: 100%;
      width: 0%;
      background: var(--barFg);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    /* Empty / no photos state */
    .empty{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
      box-sizing:border-box;
      color: var(--text);
      z-index: 11;
      background: linear-gradient(180deg, rgba(0,0,0,0.26), rgba(0,0,0,0.48));
    }
    .empty .card{
      width: min(320px, 80vw);
      border-radius: 16px;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(12px);
      padding: 16px 14px;
    }
    .empty .title{
      font-weight: 800;
      font-size: 14px;
      margin-bottom: 6px;
      letter-spacing: 0.2px;
    }
    .empty .sub{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* Controls */
    .controls{
      position:absolute;
      left:50%;
      bottom: var(--pad);
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: clamp(10px, 2.6vw, 16px);
      padding: clamp(6px, 1.6vw, 10px);
      border-radius: 999px;
      background: var(--ctrlBg);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
      z-index: 9;

      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    .controls.on{
      opacity: 1;
      pointer-events: auto;
    }

    /* Smaller, responsive buttons (skybox friendly) */
    .btn{
      width: clamp(22px, 5.2vw, 38px);
      height: clamp(22px, 5.2vw, 38px);
      border-radius: 999px;
      border: 1px solid var(--ctrlRing);
      background: rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: scale(0.96); }

    .btn svg{
      width: clamp(11px, 2.8vw, 18px);
      height: clamp(11px, 2.8vw, 18px);
      fill: none;
      stroke: rgba(255,255,255,0.86);
      stroke-width: 2.2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .btn.main{
      width: clamp(26px, 6.2vw, 42px);
      height: clamp(26px, 6.2vw, 42px);
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.24);
    }
    .btn.disabled{
      opacity: 0.28;
      cursor: default;
      pointer-events: none;
    }

    /* Hover surface */
    .hotzone{
      position:absolute;
      inset:0;
      z-index: 8;
      background: transparent;
    }
  </style>
</head>

<body>
  <div class="frame" id="frame">
    <div class="bg" id="bg"></div>
    <div class="vignette"></div>

    <!-- Two fade layers -->
    <img class="imgLayer" id="imgA" alt="photo a" />
    <img class="imgLayer" id="imgB" alt="photo b" />

    <div class="hotzone" id="hotzone"></div>

    <div class="tag" id="tag" style="display:none;"></div>

    <div class="dots" id="dots" style="display:none;"></div>

    <div class="progress" id="progress" style="display:none;">
      <div class="label" id="progressLabel">loading photo…</div>
      <div class="bar"><div class="fill" id="progressFill"></div></div>
    </div>

    <div class="controls" id="controls" aria-label="controls">
      <div class="btn" id="btnPrev" title="Previous" aria-label="Previous">
        <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
      </div>

      <div class="btn main" id="btnPlay" title="Play/Pause" aria-label="Play/Pause">
        <svg id="iconPlay" viewBox="0 0 24 24"><path d="M9 8l10 4-10 4z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" style="display:none;">
          <path d="M8 6v12"/><path d="M16 6v12"/>
        </svg>
      </div>

      <div class="btn" id="btnNext" title="Next" aria-label="Next">
        <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Params
    // -----------------------------
    const qs = new URLSearchParams(location.search);

    const apiBase = qs.get('api') || '';
    const bot = qs.get('bot') || 'winston';
    const date = qs.get('date') || '';

    const fit = (qs.get('fit') || 'contain').toLowerCase() === 'cover' ? 'cover' : 'contain';
    const fadeMs = clampInt(qs.get('fade_ms'), 450, 150, 2500);
    const intervalMs = clampInt(qs.get('interval_ms'), 2200, 700, 20000);
    const preloadN = clampInt(qs.get('preload'), 2, 0, 20);
    const cacheS = clampInt(qs.get('cache_s'), 600, 0, 86400);
    const shuffle = (qs.get('shuffle') || '1') !== '0';
    const wParam = qs.get('w');

    // DEFAULTS: UI hidden
    const showTag = (qs.get('tag') || '0') !== '0';     // default OFF
    const showDots = (qs.get('dots') || '0') !== '0';   // default OFF

    // Controls auto-hide timing
    const HIDE_MS_PLAYING = 1100; // fade sooner while playing
    const HIDE_MS_PAUSED  = 3800; // longer when paused

    // Apply CSS variables
    document.documentElement.style.setProperty('--fit', fit);
    document.documentElement.style.setProperty('--fadeMs', fadeMs + 'ms');

    // -----------------------------
    // DOM
    // -----------------------------
    const frame = document.getElementById('frame');
    const bg = document.getElementById('bg');

    const imgA = document.getElementById('imgA');
    const imgB = document.getElementById('imgB');
    let front = imgA;
    let back = imgB;

    const tagEl = document.getElementById('tag');
    const dotsEl = document.getElementById('dots');

    const progress = document.getElementById('progress');
    const progressLabel = document.getElementById('progressLabel');
    const progressFill = document.getElementById('progressFill');

    const controls = document.getElementById('controls');
    const hotzone = document.getElementById('hotzone');

    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnPlay = document.getElementById('btnPlay');
    const iconPlay = document.getElementById('iconPlay');
    const iconPause = document.getElementById('iconPause');

    // -----------------------------
    // State
    // -----------------------------
    let allUrls = [];         // from API
    let okUrls = [];          // successfully loaded
    let loadedMap = new Map();// url -> boolean ok
    let idx = 0;

    let timer = null;
    let isPlaying = true;

    // non-repeating shuffle deck
    let deck = [];
    let deckPos = 0;

    // controls hide timer
    let hideT = null;

    // -----------------------------
    // Helpers
    // -----------------------------
    function clampInt(v, def, min, max){
      const n = Number(v);
      if (!Number.isFinite(n)) return def;
      return Math.max(min, Math.min(max, Math.round(n)));
    }

    function safeText(s){
      return String(s || '').replace(/[<>]/g,'');
    }

    function showEmpty(titleText, subText){
      const d = document.createElement('div');
      d.className = 'empty';
      d.innerHTML =
        '<div class="card">' +
          '<div class="title">' + safeText(titleText) + '</div>' +
          '<div class="sub">' + safeText(subText) + '</div>' +
        '</div>';
      frame.appendChild(d);
    }

    function showProgress(on, label){
      if (!on){
        progress.classList.remove('on');
        progress.style.display = 'none';
        return;
      }
      progress.style.display = '';
      if (label) progressLabel.textContent = label;
      requestAnimationFrame(() => progress.classList.add('on'));
    }

    function setProgress(pct){
      const p = Math.max(0, Math.min(100, pct));
      progressFill.style.width = p + '%';
    }

    function syncPlayIcon(){
      if (isPlaying){
        iconPlay.style.display = 'none';
        iconPause.style.display = '';
      } else {
        iconPlay.style.display = '';
        iconPause.style.display = 'none';
      }
    }

    function disablePrevNextIfNeeded(){
      const one = (okUrls.length <= 1);
      if (one){
        btnPrev.classList.add('disabled');
        btnNext.classList.add('disabled');
      } else {
        btnPrev.classList.remove('disabled');
        btnNext.classList.remove('disabled');
      }
    }

    function showControls(){
      controls.classList.add('on');
      if (showTag) tagEl.classList.add('on');
      if (showDots) dotsEl.classList.add('on');
      scheduleHideControls();
    }

    function hideControlsNow(){
      controls.classList.remove('on');
      tagEl.classList.remove('on');
      dotsEl.classList.remove('on');
    }

    function scheduleHideControls(){
      if (hideT) clearTimeout(hideT);
      const ms = isPlaying ? HIDE_MS_PLAYING : HIDE_MS_PAUSED;
      hideT = setTimeout(() => {
        hideControlsNow();
      }, ms);
    }

    function buildApiUrl(){
      if (!apiBase) return '';
      const u = new URL(apiBase, location.href);
      if (bot) u.searchParams.set('bot', bot);
      if (date) u.searchParams.set('date', date);
      if (wParam) u.searchParams.set('w', wParam);
      if (cacheS) u.searchParams.set('cache_s', String(cacheS));
      return u.toString();
    }

    async function fetchJson(url){
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      return await resp.json();
    }

    function shuffleArray(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function resetDeck(currentIndex){
      const indices = okUrls.map((_, i) => i);
      let ordered = shuffle ? shuffleArray(indices) : indices;

      // avoid immediate repeat
      if (shuffle && okUrls.length > 1 && ordered[0] === currentIndex){
        const swapWith = 1 + Math.floor(Math.random() * (ordered.length - 1));
        [ordered[0], ordered[swapWith]] = [ordered[swapWith], ordered[0]];
      }
      deck = ordered;
      deckPos = 0;
    }

    function nextFromDeck(){
      if (okUrls.length <= 1) return 0;
      if (!deck.length || deckPos >= deck.length){
        resetDeck(idx);
      }
      if (okUrls.length > 1 && deck[deckPos] === idx){
        deckPos++;
        if (deckPos >= deck.length) resetDeck(idx);
      }
      const ni = deck[deckPos];
      deckPos++;
      return ni;
    }

    // A simple prev behavior: go to previous index in current deck history is complex;
    // for UX it’s fine to just wrap backward.
    function prevIndexSimple(){
      if (okUrls.length <= 1) return 0;
      return (idx - 1 + okUrls.length) % okUrls.length;
    }

    function setBgFor(src){
      bg.style.backgroundImage = `url("${src}")`;
      bg.classList.add('on');
    }

    function updateDots(){
      if (!showDots) return;
      const n = okUrls.length;
      dotsEl.innerHTML = '';
      const maxDots = 10; // keep classy in small skyboxes
      if (n <= 1){
        dotsEl.style.display = 'none';
        return;
      }
      dotsEl.style.display = '';
      const use = Math.min(n, maxDots);
      for (let i = 0; i < use; i++){
        const d = document.createElement('div');
        d.className = 'dot' + (i === (idx % use) ? ' on' : '');
        dotsEl.appendChild(d);
      }
    }

    function setTagText(dateKey, count){
      if (!showTag) return;
      tagEl.textContent = `${dateKey || date || ''} • ${bot}${count ? (' • ' + count) : ''}`;
      tagEl.style.display = '';
    }

    function swapLayers(){
      const tmp = front;
      front = back;
      back = tmp;
    }

    function showIndex(newIndex){
      if (!okUrls.length) return;
      const src = okUrls[newIndex];
      if (!src) return;

      // Prepare back layer
      back.src = src;
      back.classList.add('on');
      front.classList.remove('on');

      // swap references after the fade completes
      setTimeout(() => {
        swapLayers();
        // ensure back (now behind) is off for next time
        back.classList.remove('on');
        idx = newIndex;
        setBgFor(okUrls[idx]);
        updateDots();
      }, fadeMs);

      // bg updates immediately (feels responsive)
      setBgFor(src);
    }

    function stopTimer(){
      if (timer) clearInterval(timer);
      timer = null;
    }

    function startTimer(){
      stopTimer();
      if (!isPlaying) return;
      if (okUrls.length <= 1) return;
      timer = setInterval(() => {
        const ni = nextFromDeck();
        showIndex(ni);
      }, Math.max(350, intervalMs));
    }

    function wireControls(){
      // show controls only on hover/move/tap (DEFAULT hidden)
      const bump = () => showControls();

      frame.addEventListener('pointermove', bump, { passive: true });
      frame.addEventListener('mouseenter', bump, { passive: true });
      hotzone.addEventListener('click', bump);

      btnPlay.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        bump();
        isPlaying = !isPlaying;
        syncPlayIcon();
        startTimer();
      });

      btnNext.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        bump();
        if (okUrls.length <= 1) return;
        const ni = nextFromDeck();
        showIndex(ni);
      });

      btnPrev.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        bump();
        if (okUrls.length <= 1) return;
        const pi = prevIndexSimple();
        showIndex(pi);
      });
    }

    function preloadImage(src){
      return new Promise((resolve) => {
        const im = new Image();
        im.decoding = 'async';
        im.loading = 'eager';
        im.onload = () => resolve({ ok:true, src });
        im.onerror = () => resolve({ ok:false, src });
        im.src = src;
      });
    }

    async function loadFirstThenBackground(){
      // Show progress while we get the very first image
      showProgress(true, 'loading photo…');
      setProgress(10);

      // Try to load images in order until we get the first successful one
      let firstOk = null;
      for (let i = 0; i < allUrls.length; i++){
        const url = allUrls[i];
        const r = await preloadImage(url);
        loadedMap.set(url, r.ok);
        setProgress(Math.round(((i+1) / Math.max(1, allUrls.length)) * 40)); // early stage progress
        if (r.ok && !firstOk){
          firstOk = url;
          break;
        }
      }

      if (!firstOk){
        showProgress(false);
        return false;
      }

      // Start okUrls with firstOk
      okUrls = [firstOk];

      // Render immediately
      front.src = firstOk;
      front.classList.add('on');
      setBgFor(firstOk);

      // Hide progress quickly once we have first image
      setTimeout(() => showProgress(false), 180);

      // Background preload: first do preloadN quickly, then the rest
      const remaining = allUrls.filter(u => u !== firstOk);

      let loadedCount = 1;
      const total = allUrls.length;

      // show a subtle progress bar only while doing the "preloadN" burst
      if (preloadN > 0 && remaining.length){
        showProgress(true, 'loading more…');
        setProgress(Math.round((loadedCount / total) * 100));
      }

      // Burst preload
      for (let i = 0; i < Math.min(preloadN, remaining.length); i++){
        const url = remaining[i];
        const r = await preloadImage(url);
        loadedMap.set(url, r.ok);
        if (r.ok) okUrls.push(url);
        loadedCount++;
        if (preloadN > 0){
          setProgress(Math.round((loadedCount / total) * 100));
        }
      }

      if (preloadN > 0){
        setTimeout(() => showProgress(false), 220);
      }

      // Continue the rest in the background (no UI blocking)
      (async () => {
        for (let i = preloadN; i < remaining.length; i++){
          const url = remaining[i];
          const r = await preloadImage(url);
          loadedMap.set(url, r.ok);
          if (r.ok) okUrls.push(url);
        }

        // After background finishes, rebuild deck to include all okUrls
        if (okUrls.length > 1){
          resetDeck(idx);
          disablePrevNextIfNeeded();
          updateDots();
        }
      })();

      return true;
    }

    async function main(){
      wireControls();

      // DEFAULT: UI hidden (no initial showControls call)
      hideControlsNow();
      if (showTag){
        tagEl.style.display = '';
        tagEl.classList.remove('on'); // still hidden until hover/move
      }
      if (showDots){
        dotsEl.style.display = '';
        dotsEl.classList.remove('on'); // still hidden until hover/move
      }

      const apiUrl = buildApiUrl();
      if (!apiUrl){
        showEmpty('Missing api', 'Pass api=<your api_photo_reel url> in the query string.');
        return;
      }

      try{
        const data = await fetchJson(apiUrl);

        if (!data || !data.ok){
          const err = (data && data.error) ? String(data.error) : 'API returned not ok';
          showEmpty('No photos', err);
          return;
        }

        const dateKey = data.dateKey || date || '';
        const list = Array.isArray(data.photos) ? data.photos.slice() : [];
        if (!list.length){
          showEmpty('No photos', (dateKey ? dateKey : '') + (bot ? (' • ' + bot) : ''));
          return;
        }

        allUrls = list;

        // optional tag text, but still hidden by default until hover/move
        setTagText(dateKey, list.length ? (list.length + ' photos') : '');
        if (showTag) tagEl.style.display = '';

        // Dots container exists but will be updated after okUrls has more than 1
        if (showDots) dotsEl.style.display = '';

        // Load first photo ASAP, then background
        const ok = await loadFirstThenBackground();
        if (!ok || !okUrls.length){
          showEmpty('No photos', 'All photos failed to load (permissions or invalid URLs).');
          return;
        }

        // Now that we have at least 1 ok image:
        idx = 0;
        disablePrevNextIfNeeded();
        syncPlayIcon();
        updateDots();
        resetDeck(idx);
        startTimer();

      } catch (e){
        showEmpty('No photos', 'Failed to load: ' + String(e && e.message ? e.message : e));
      }
    }

    main();
  </script>
</body>
</html>

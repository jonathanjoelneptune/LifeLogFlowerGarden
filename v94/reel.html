<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LifeLog Photo Reel</title>
  <style>
    :root{
      --radius: 16px;

      --hudPad: 10px;
      --hudFont: 12px;
      --hudBg: rgba(0,0,0,0.42);
      --hudFg: rgba(255,255,255,0.92);

      --barBg: rgba(255,255,255,0.16);
      --barFg: rgba(255,255,255,0.78);

      --ctrlBg: rgba(0,0,0,0.42);
      --ctrlFg: rgba(255,255,255,0.92);
      --ctrlFgDim: rgba(255,255,255,0.70);
      --ctrlRing: rgba(255,255,255,0.16);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: transparent;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .wrap{
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(0,0,0,0.12);
    }

    /* Soft vignette */
    .wrap:before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(120% 90% at 50% 50%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.16) 72%, rgba(0,0,0,0.30) 100%);
      z-index: 6;
    }

    /* Background blur layer for portrait shots */
    .bg {
      position:absolute;
      inset:0;
      background-position:center;
      background-size: cover;
      filter: blur(28px);
      transform: scale(1.12);
      opacity: 0;
      transition: opacity 420ms cubic-bezier(.2,.8,.2,1);
      z-index: 1;
    }
    .bg.on { opacity: 0.92; }

    .bgShade{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.20);
      opacity: 0;
      transition: opacity 420ms cubic-bezier(.2,.8,.2,1);
      z-index: 2;
    }
    .bgShade.on{ opacity: 1; }

    /* Two-layer crossfade */
    .frame{
      position:absolute;
      inset:0;
      z-index: 3;
    }
    .layer{
      position:absolute;
      inset:0;
      opacity: 0;
      transition: opacity 520ms cubic-bezier(.22,.61,.36,1);
      will-change: opacity;
    }
    .layer.show{ opacity: 1; }

    img.photo{
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scale(1.01);
      will-change: transform;
      user-select: none;
      -webkit-user-drag: none;
    }

    .hud{
      position:absolute;
      left: var(--hudPad);
      bottom: var(--hudPad);
      padding: 7px 10px;
      border-radius: 12px;
      background: var(--hudBg);
      color: var(--hudFg);
      font-size: var(--hudFont);
      backdrop-filter: blur(8px);
      max-width: calc(100% - (var(--hudPad) * 2));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      z-index: 7;
      pointer-events:none;
    }

    .barWrap{
      position:absolute;
      left: var(--hudPad);
      right: var(--hudPad);
      bottom: calc(var(--hudPad) + 40px);
      height: 4px;
      border-radius: 999px;
      background: var(--barBg);
      overflow:hidden;
      z-index: 7;
      opacity: 0;
      transition: opacity 240ms ease;
      pointer-events:none;
    }
    .barWrap.on{ opacity: 1; }
    .bar{
      height: 100%;
      width: 0%;
      background: var(--barFg);
      border-radius: 999px;
      transition: width 180ms ease;
    }

    /* Controls */
    .controls{
      position:absolute;
      left: 50%;
      bottom: calc(var(--hudPad) + 44px);
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--ctrlBg);
      backdrop-filter: blur(10px);
      z-index: 7;

      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none; /* enabled when visible */
    }
    .controls.on{
      opacity: 1;
      pointer-events: auto;
    }

    .btn{
      width: 38px;
      height: 38px;
      border-radius: 999px;
      border: 1px solid var(--ctrlRing);
      background: rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: pointer;
      user-select:none;
      touch-action: manipulation;
    }
    .btn:active{
      transform: scale(0.98);
      background: rgba(255,255,255,0.09);
    }
    .btn svg{
      width: 18px;
      height: 18px;
      fill: var(--ctrlFg);
      opacity: 0.92;
    }
    .btn.dim svg{ opacity: 0.74; }

    /* No photos state */
    .empty{
      position:absolute;
      inset:0;
      z-index: 8;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      box-sizing: border-box;
      background:
        radial-gradient(120% 90% at 50% 45%, rgba(255,255,255,0.09) 0%, rgba(255,255,255,0.05) 55%, rgba(0,0,0,0.10) 100%),
        linear-gradient(180deg, rgba(0,0,0,0.10), rgba(0,0,0,0.16));
    }
    .card{
      width:min(520px, 92vw);
      border-radius: 18px;
      padding: 18px 18px 16px;
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.22);
      color: rgba(255,255,255,0.92);
    }
    .title{
      font-size: 14px;
      font-weight: 750;
      letter-spacing: 0.2px;
      margin: 0 0 6px 0;
    }
    .sub{
      font-size: 12px;
      line-height: 1.35;
      opacity: 0.92;
    }
    .hint{
      margin-top: 10px;
      font-size: 11px;
      line-height: 1.35;
      opacity: 0.72;
    }
    .err{
      margin-top: 10px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 10.5px;
      line-height: 1.35;
      opacity: 0.70;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Reveal controls on hover/tap area */
    .hotzone{
      position:absolute;
      left:0;
      right:0;
      bottom:0;
      height: 120px;
      z-index: 7;
      background: transparent;
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">
    <div class="bg" id="bg"></div>
    <div class="bgShade" id="bgShade"></div>

    <div class="frame" id="frame">
      <div class="layer" id="layerA"><img class="photo" id="imgA" alt="photo A"></div>
      <div class="layer" id="layerB"><img class="photo" id="imgB" alt="photo B"></div>
    </div>

    <div class="barWrap" id="barWrap"><div class="bar" id="bar"></div></div>
    <div class="hud" id="hud">loading…</div>

    <div class="controls" id="controls" aria-label="reel controls">
      <div class="btn dim" id="btnPrev" title="Previous" aria-label="Previous">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M15.5 5.5 9 12l6.5 6.5-1.4 1.4L6.2 12l7.9-7.9z"/></svg>
      </div>

      <div class="btn" id="btnPlay" title="Play/Pause" aria-label="Play/Pause">
        <svg id="iconPlay" viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"/></svg>
        <svg id="iconPause" viewBox="0 0 24 24" aria-hidden="true" style="display:none"><path d="M7 5h4v14H7zm6 0h4v14h-4z"/></svg>
      </div>

      <div class="btn dim" id="btnNext" title="Next" aria-label="Next">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8.5 18.5 15 12 8.5 5.5l1.4-1.4L17.8 12l-7.9 7.9z"/></svg>
      </div>
    </div>

    <div class="hotzone" id="hotzone" aria-hidden="true"></div>
  </div>

<script>
/* ---------------------------
 * Params + defaults
 * --------------------------- */
const QS = new URLSearchParams(location.search);

const bot = (QS.get("bot") || "").trim().toLowerCase();
const dateKey = (QS.get("date") || "").trim();

const fit = ((QS.get("fit") || "cover") + "").toLowerCase() === "contain" ? "contain" : "cover";
const w = clampInt(QS.get("w"), 1200, 320, 4096);

const preloadCount = clampInt(QS.get("preload"), 2, 0, 20);
const cacheS = clampInt(QS.get("cache_s"), 600, 0, 86400);

const intervalMs = clampInt(QS.get("interval_ms"), 2200, 600, 30000);
const fadeMs = clampInt(QS.get("fade_ms"), 450, 150, 4000);

const shuffleFlag = (QS.get("shuffle") || "0").trim() === "1";

// Apps Script WebApp exec base (no trailing slash)
const apiBase = (QS.get("api") || "https://script.google.com/macros/s/AKfycbyHPnSrEOdYJwoIQpRk4SajFg9cgpSeXsH0ilg9-c2EglqzeSIubVhgy7WogI-Idsu8/exec").trim();

/* ---------------------------
 * DOM
 * --------------------------- */
const wrap = document.getElementById("wrap");
const bg = document.getElementById("bg");
const bgShade = document.getElementById("bgShade");

const layerA = document.getElementById("layerA");
const layerB = document.getElementById("layerB");
const imgA = document.getElementById("imgA");
const imgB = document.getElementById("imgB");

const hud = document.getElementById("hud");
const barWrap = document.getElementById("barWrap");
const bar = document.getElementById("bar");

const controls = document.getElementById("controls");
const hotzone = document.getElementById("hotzone");
const btnPrev = document.getElementById("btnPrev");
const btnNext = document.getElementById("btnNext");
const btnPlay = document.getElementById("btnPlay");
const iconPlay = document.getElementById("iconPlay");
const iconPause = document.getElementById("iconPause");

// Apply fit + timing
imgA.style.objectFit = fit;
imgB.style.objectFit = fit;
layerA.style.transitionDuration = `${fadeMs}ms`;
layerB.style.transitionDuration = `${fadeMs}ms`;

bg.style.transitionDuration = `${Math.max(220, Math.min(900, fadeMs + 120))}ms`;
bgShade.style.transitionDuration = `${Math.max(220, Math.min(900, fadeMs + 120))}ms`;

/* ---------------------------
 * Controls show/hide
 * --------------------------- */
let controlsHideTimer = null;
function showControls(){
  controls.classList.add("on");
  if (controlsHideTimer) clearTimeout(controlsHideTimer);
  controlsHideTimer = setTimeout(() => controls.classList.remove("on"), 2500);
}
hotzone.addEventListener("mousemove", showControls, { passive:true });
hotzone.addEventListener("mouseenter", showControls, { passive:true });
hotzone.addEventListener("touchstart", showControls, { passive:true });

/* ---------------------------
 * JSONP loader (CORS-safe)
 * --------------------------- */
function fetchJsonp(url, timeoutMs = 12000){
  return new Promise((resolve, reject) => {
    const cbName = "__llReelCb_" + Math.random().toString(36).slice(2);
    const script = document.createElement("script");
    const timer = setTimeout(() => {
      cleanup();
      reject(new Error("jsonp timeout"));
    }, timeoutMs);

    function cleanup(){
      clearTimeout(timer);
      try { delete window[cbName]; } catch(e) { window[cbName] = undefined; }
      if (script && script.parentNode) script.parentNode.removeChild(script);
    }

    window[cbName] = (data) => { cleanup(); resolve(data); };
    script.onerror = () => { cleanup(); reject(new Error("jsonp load error")); };

    const u = new URL(url);
    u.searchParams.set("format", "jsonp");
    u.searchParams.set("callback", cbName);

    script.src = u.toString();
    document.head.appendChild(script);
  });
}

/* ---------------------------
 * Caching
 * --------------------------- */
function cacheKey(){ return `ll_photoreel_v1:${bot}:${dateKey}:w${w}`; }

function readCache(){
  if (!cacheS) return null;
  try{
    const raw = localStorage.getItem(cacheKey());
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || !obj.t || !Array.isArray(obj.photos)) return null;
    const ageMs = Date.now() - obj.t;
    if (ageMs > cacheS * 1000) return null;
    return obj;
  } catch(e){ return null; }
}

function writeCache(photos){
  if (!cacheS) return;
  try{
    localStorage.setItem(cacheKey(), JSON.stringify({ t: Date.now(), photos }));
  } catch(e){}
}

/* ---------------------------
 * Utils
 * --------------------------- */
function clampInt(v, def, min, max){
  const n = Number(v);
  if (!isFinite(n)) return def;
  return Math.max(min, Math.min(max, Math.round(n)));
}

function escapeHtml(s){
  return String(s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function setHud(text){ hud.textContent = text; }
function setProgress(p01){
  const p = Math.max(0, Math.min(1, Number(p01) || 0));
  bar.style.width = `${Math.round(p * 100)}%`;
}

function showEmpty({ title, sub, hint, err }){
  const div = document.createElement("div");
  div.className = "empty";
  div.innerHTML = `
    <div class="card">
      <div class="title">${escapeHtml(title || "No photos")}</div>
      <div class="sub">${escapeHtml(sub || "")}</div>
      ${hint ? `<div class="hint">${escapeHtml(hint)}</div>` : ``}
      ${err ? `<div class="err">${escapeHtml(err)}</div>` : ``}
    </div>`;
  wrap.appendChild(div);
}

/* ---------------------------
 * Rotation with no repeats
 * --------------------------- */
let photos = [];
let ok = [];
let failed = new Set();
let started = false;

let showingLayerA = true;
let idxCurrent = -1;

let deck = [];
let deckPos = 0;

function rebuildDeck(avoidFirstIdx){
  deck = ok.slice();
  if (shuffleFlag) shuffleInPlace(deck);
  if (deck.length > 1 && avoidFirstIdx >= 0 && deck[0] === avoidFirstIdx){
    const k = deck.findIndex(x => x !== avoidFirstIdx);
    if (k > 0) [deck[0], deck[k]] = [deck[k], deck[0]];
  }
  deckPos = 0;
}

function nextIndex(){
  if (ok.length <= 1) return idxCurrent;

  const okSet = new Set(ok);
  const deckValid = deck.length === ok.length && deck.every(x => okSet.has(x));
  if (!deckValid || deckPos >= deck.length){
    rebuildDeck(idxCurrent);
  }

  let next = deck[deckPos++];
  if (ok.length > 1 && next === idxCurrent){
    if (deckPos < deck.length) next = deck[deckPos++];
    else {
      rebuildDeck(idxCurrent);
      next = deck[deckPos++];
    }
  }
  return next;
}

function prevIndex(){
  if (ok.length <= 1) return idxCurrent;

  const okSet = new Set(ok);
  const deckValid = deck.length === ok.length && deck.every(x => okSet.has(x));
  if (!deckValid || deck.length < 2){
    rebuildDeck(idxCurrent);
  }

  // We consider "deckPos" points to the next item.
  // Previous is the item before the current next position.
  let pos = deckPos - 2; // -1 would be current; -2 is previous
  if (pos < 0) pos = deck.length + pos;
  if (pos < 0) pos = 0;

  let prev = deck[pos];
  if (ok.length > 1 && prev === idxCurrent){
    pos = pos - 1;
    if (pos < 0) pos = deck.length - 1;
    prev = deck[pos];
  }

  // Move deckPos so that "next" continues forward from the correct point
  deckPos = pos + 1;
  return prev;
}

/* ---------------------------
 * Image loading
 * --------------------------- */
function preloadOne(src){
  return new Promise((resolve) => {
    const im = new Image();
    im.decoding = "async";
    im.loading = "eager";
    im.onload = () => resolve({ ok:true, w: im.naturalWidth || 0, h: im.naturalHeight || 0 });
    im.onerror = () => resolve({ ok:false, w:0, h:0 });
    im.src = src;
  });
}

function applyBackdrop(src, isPortrait){
  bg.style.backgroundImage = `url("${src}")`;
  if (isPortrait){
    bg.classList.add("on");
    bgShade.classList.add("on");
  } else {
    bg.classList.remove("on");
    bgShade.classList.remove("on");
  }
}

function showIndex(i){
  if (i == null || i < 0 || i >= photos.length) return;
  if (i === idxCurrent) return;

  const src = photos[i];

  const showLayer = showingLayerA ? layerA : layerB;
  const hideLayer = showingLayerA ? layerB : layerA;
  const showImg = showingLayerA ? imgA : imgB;

  showImg.src = src;
  showImg.onload = () => {
    const isPortrait = (showImg.naturalHeight || 0) > (showImg.naturalWidth || 0);
    applyBackdrop(src, isPortrait);
  };

  hideLayer.classList.remove("show");
  showLayer.classList.add("show");

  showingLayerA = !showingLayerA;
  idxCurrent = i;

  setHud(`${dateKey} • ${bot} • ${photos.length} photos`);
}

/* ---------------------------
 * API
 * --------------------------- */
function buildApiUrl(){
  const u = new URL(apiBase);
  u.searchParams.set("r", "api_photo_reel");
  u.searchParams.set("bot", bot);
  u.searchParams.set("date", dateKey);
  u.searchParams.set("w", String(w));
  u.searchParams.set("cache_s", String(cacheS));
  return u.toString();
}

/* ---------------------------
 * Playback state + transport
 * --------------------------- */
let isPlaying = true;
let timer = null;

function syncPlayIcon(){
  iconPlay.style.display = isPlaying ? "none" : "";
  iconPause.style.display = isPlaying ? "" : "none";
}

function stopTimer(){
  if (timer) clearInterval(timer);
  timer = null;
}

function startTimer(){
  stopTimer();
  if (!isPlaying) return;
  timer = setInterval(() => {
    if (!started) return;
    if (ok.length <= 1) return;
    const nxt = nextIndex();
    if (nxt !== idxCurrent) showIndex(nxt);
  }, intervalMs);
}

btnPlay.addEventListener("click", (ev) => {
  ev.preventDefault();
  showControls();
  isPlaying = !isPlaying;
  syncPlayIcon();
  startTimer();
}, { passive:false });

btnNext.addEventListener("click", (ev) => {
  ev.preventDefault();
  showControls();
  if (!started || ok.length <= 1) return;
  const nxt = nextIndex();
  if (nxt !== idxCurrent) showIndex(nxt);
}, { passive:false });

btnPrev.addEventListener("click", (ev) => {
  ev.preventDefault();
  showControls();
  if (!started || ok.length <= 1) return;
  const prv = prevIndex();
  if (prv !== idxCurrent) showIndex(prv);
}, { passive:false });

syncPlayIcon();

/* ---------------------------
 * Main load
 * --------------------------- */
async function loadPhotos(){
  if (!bot || !dateKey){
    showEmpty({
      title: "Missing params",
      sub: "Need bot and date",
      hint: 'Example: ?bot=winston&date=2025-12-20&fit=contain&preload=2&cache_s=600&interval_ms=2200&fade_ms=450&shuffle=1'
    });
    setHud("missing params");
    return;
  }

  const cached = readCache();
  if (cached && Array.isArray(cached.photos) && cached.photos.length){
    photos = cached.photos.slice();
  } else {
    const url = buildApiUrl();
    setHud("loading photos…");
    let data;
    try{
      data = await fetchJsonp(url);
    } catch(e){
      showEmpty({
        title: "Could not load",
        sub: `${dateKey} • ${bot}`,
        hint: "Check that your WebApp route r=api_photo_reel is deployed and accessible.",
        err: String(e && e.message ? e.message : e)
      });
      setHud("load error");
      return;
    }

    if (!data || !data.ok){
      showEmpty({
        title: "No photos",
        sub: `${dateKey} • ${bot}`,
        hint: "No photo links found for this day, or the API returned an error.",
        err: data && data.error ? String(data.error) : ""
      });
      setHud(`${dateKey} • ${bot} • 0 photos`);
      return;
    }

    photos = (data.photos || []).map(s => String(s || "").trim()).filter(Boolean);
    if (!photos.length){
      showEmpty({
        title: "No photos",
        sub: `${dateKey} • ${bot}`,
        hint: "This day has no media links."
      });
      setHud(`${dateKey} • ${bot} • 0 photos`);
      return;
    }

    writeCache(photos);
  }

  // Preload phase
  if (preloadCount > 0){
    barWrap.classList.add("on");
    setProgress(0);

    const toTry = Math.min(preloadCount, photos.length);
    let done = 0;

    const concurrency = Math.min(3, toTry);
    let cursor = 0;

    async function worker(){
      while (cursor < toTry){
        const i = cursor++;
        const res = await preloadOne(photos[i]);
        done++;
        setProgress(done / toTry);

        if (res.ok){
          if (!ok.includes(i)) ok.push(i);
        } else {
          failed.add(i);
        }
      }
    }

    const workers = [];
    for (let k = 0; k < concurrency; k++) workers.push(worker());
    await Promise.all(workers);

    setTimeout(() => { barWrap.classList.remove("on"); }, 320);
  }

  // Ensure at least one ok
  if (!ok.length){
    const res = await preloadOne(photos[0]);
    if (res.ok) ok.push(0);
    else failed.add(0);
  }

  // Background warm load
  warmLoadRemaining_();

  if (!ok.length){
    showEmpty({
      title: "No photos",
      sub: `${dateKey} • ${bot}`,
      hint: "Photos exist, but none could be loaded. Check file permissions (Anyone with link)."
    });
    setHud(`${dateKey} • ${bot} • 0 photos`);
    return;
  }

  // Start
  rebuildDeck(-1);
  started = true;

  const first = deck[deckPos++] ?? ok[0];
  showIndex(first);

  // Start playback timer
  startTimer();

  // Show controls briefly on load
  showControls();
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function warmLoadRemaining_(){
  setTimeout(async () => {
    for (let i = 0; i < photos.length; i++){
      if (ok.includes(i) || failed.has(i)) continue;
      const res = await preloadOne(photos[i]);
      if (res.ok) ok.push(i);
      else failed.add(i);
      await sleep(80);
    }

    if (ok.length > 1 && (deck.length < ok.length)){
      rebuildDeck(idxCurrent);
    }
  }, 150);
}

loadPhotos();
</script>
</body>
</html>
